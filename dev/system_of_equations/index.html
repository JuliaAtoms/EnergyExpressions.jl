<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>System of equations Â· EnergyExpressions</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script src="../assets/latex.js"></script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.svg" alt="EnergyExpressions logo"/></a><h1>EnergyExpressions</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Theory</span><ul><li><a class="toctext" href="../notation/">Notation</a></li><li><a class="toctext" href="../energy_expressions/">Energy Expressions</a></li><li><a class="toctext" href="../calculus_of_variations/">Calculus of Variations</a></li></ul></li><li><span class="toctext">Implementation</span><ul><li><a class="toctext" href="../conjugate_orbitals/">Conjugate orbitals</a></li><li><a class="toctext" href="../slater_determinants/">Slater determinants</a></li><li><a class="toctext" href="../nbody_operators/">N-body operators</a></li><li><a class="toctext" href="../nbody_matrix_elements/">N-body matrix elements</a></li><li><a class="toctext" href="../common_operators/">Common N-body operators</a></li><li><a class="toctext" href="../equations/">N-body equations</a></li><li><a class="toctext" href="../variations/">Variation</a></li><li class="current"><a class="toctext" href>System of equations</a><ul class="internal"><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Implementation-1">Implementation</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Implementation</li><li><a href>System of equations</a></li></ul><a class="edit-page" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/master/docs/src/system_of_equations.md"><span class="fa">ï‚›</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>System of equations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="System-of-equations-1" href="#System-of-equations-1">System of equations</a></h1><p>When dealing with large energy expressions resulting from many configurations, when deriving the orbital equations (see <a href="@ref"><code>N-body equations</code></a> and <a href="@ref"><code>Calculus of Variations â€“ Implementation</code></a>), many of the integrals involved will be shared between the different terms of the equations. It is therefore of interest to gather a list of integrals that can be calculated once at every iteration (in a self-consistent procedure for finding eigenstates, or in time-propagation), and whose values can then be reused when solving the individual equations. The routines described below, although primitive, aid in this effort.</p><p>The idea is the following: With an energy expression on the form</p><div>\[\begin{equation}
E(\vec{P},\vec{c}) = \frac{\vec{c}^H
\mat{H}\vec{c}}{\vec{c}^H\vec{c}}
\end{equation}\]</div><p>where <span>$\vec{P}$</span> is a set of orbitals, <span>$\vec{c}$</span> is a vector of mixing coefficients, and</p><div>\[\begin{equation}
\mat{H}_{ij} \defd \matrixel{\chi_i}{\Hamiltonian}{\chi_j},
\end{equation}\]</div><p>all terms of the equations can be written on the form</p><div>\[\begin{equation}
\label{eqn:equation-term}
\operator{A}\ket{\chi}
\underbrace{\left[
\sum_n \alpha_n \conj{c}_{i_n} c_{j_n}
\prod_k \int_{n_k}
\right]}_{\textrm{Rank 0}},
\end{equation}\]</div><p>(or on its dual form with conjugated orbitals) where <span>$\operator{A}$</span> is some one-body operator, <span>$\alpha_n$</span> a coefficient due to the energy expression, <span>$\conj{c}_{i_n} c_{j_n}$</span> the coefficient due to the multi-configurational expansion, and finally <span>$\int_{n_k}$</span> all the extra integrals (which are necessarily zero-body operators) that may appear due to non-orthogonal orbitals (and which may be shared between many equations). The operator <span>$\operator{A}$</span> can have ranks 0â€“2; formally, it can only have rank 0 (multiplication by a scalar) or 2 (multiplication by a matrix). What we somewhat sloppily to refer by â€œrank 1â€ is an operator of rank 2, but which is diagonal in the underlying coordinate, such as a local potential.</p><p>Thus, to efficiently perform an iteration, one would first compute all common integrals <span>$\int_k$</span>, and then for every equation term of the form <span>$\eqref{eqn:equation-term}$</span>, form the coefficient in the brakets, calculate the action of the operator <span>$\operator{A}$</span> on the orbital <span>$\chi$</span>, multiplied the coefficient.</p><p>There are a few important special cases of <span>$\eqref{eqn:equation-term}$</span>:</p><ol><li><p>Field-free, one-body Hamiltonian, i.e. <span>$\operator{A}=\hamiltonian_0$</span>. This is the contribution from the orbital <span>$\ket{\chi}$</span> to itself. Rank 2.</p></li><li><p>One-body Hamiltonian, including field, i.e. <span>$\operator{A}=\hamiltonian$</span>. This is the contribution from another orbital <span>$\ket{\chi&#39;}$</span> to <span>$\ket{\chi}$</span> via some off-diagonal coupling, such as an external field (e.g. an electroâ€“magnetic field). Rank 2.</p></li><li><p>Direct interaction, i.e. <span>$\operator{A}=\direct{kl}$</span>, where two other orbitals <span>$\ket{\chi_k}$</span> and <span>$\ket{\chi_l}$</span> together form a potential acting on <span>$\ket{\chi}$</span>. â€œRank 1â€.</p></li><li><p>Exchange interaction, i.e. <span>$\operator{A}=\exchange{kl}$</span>, where another orbital <span>$\ket{\chi_k}$</span> and <span>$\ket{\chi}$</span> together form a potential acting on a third orbital <span>$\ket{\chi_l}$</span>. Rank 2.</p></li><li><p>Source term, i.e. a contribution that does not involve <span>$\ket{\chi}$</span> in any way. This term arises from other configurations in the multi-configurational expansion. Case 2. is also formulated in this way. Rank 0â€“2. If for some reason the source orbital and/or the operator acting on it is fixed, it may be possible to precompute the effect of the operator on the source orbital and reduce the computational complexity to a rank 0-equivalent operation.</p></li></ol><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>We start by defining a set of configurations and specifying that a few of the constituent orbitals are non-orthogonal:</p><pre><code class="language-julia-repl">julia&gt; cfgs = [[:i, :j, :l, :kÌƒ], [:i, :j, :k, :lÌƒ]]
2-element Array{Array{Symbol,1},1}:
 [:i, :j, :l, :kÌƒ]
 [:i, :j, :k, :lÌƒ]

julia&gt; continua = [:kÌƒ, :lÌƒ]
2-element Array{Symbol,1}:
 :kÌƒ
 :lÌƒ

julia&gt; overlaps = [OrbitalOverlap(i,j) for i in continua for j in continua]
4-element Array{OrbitalOverlap{Symbol,Symbol},1}:
 âŸ¨kÌƒ|kÌƒâŸ©
 âŸ¨kÌƒ|lÌƒâŸ©
 âŸ¨lÌƒ|kÌƒâŸ©
 âŸ¨lÌƒ|lÌƒâŸ©</code></pre><p>We then set up the energy expression as before:</p><pre><code class="language-julia-repl">julia&gt; H = OneBodyHamiltonian() + CoulombInteraction()
hÌ‚ + gÌ‚

julia&gt; E = Matrix(H, SlaterDeterminant.(cfgs), overlaps)
2Ã—2 Array{EnergyExpressions.NBodyMatrixElement,2}:
 (i|i)âŸ¨kÌƒ|kÌƒâŸ© + (j|j)âŸ¨kÌƒ|kÌƒâŸ© + (l|l)âŸ¨kÌƒ|kÌƒâŸ© + (kÌƒ|kÌƒ) - G(i,j)âŸ¨kÌƒ|kÌƒâŸ© + F(i,j)âŸ¨kÌƒ|kÌƒâŸ© + â€¦ - G(i,kÌƒ) + F(i,kÌƒ) - G(j,kÌƒ) + F(j,kÌƒ) - G(l,kÌƒ) + F(l,kÌƒ)  â€¦  (l|k)âŸ¨kÌƒ|lÌƒâŸ© - [i l|k i]âŸ¨kÌƒ|lÌƒâŸ© + [i l|i k]âŸ¨kÌƒ|lÌƒâŸ© - [j l|k j]âŸ¨kÌƒ|lÌƒâŸ© + [j l|j k]âŸ¨kÌƒ|lÌƒâŸ© - [l kÌƒ|lÌƒ k] + [l kÌƒ|k lÌƒ]
 (k|l)âŸ¨lÌƒ|kÌƒâŸ© - [i k|l i]âŸ¨lÌƒ|kÌƒâŸ© + [i k|i l]âŸ¨lÌƒ|kÌƒâŸ© - [j k|l j]âŸ¨lÌƒ|kÌƒâŸ© + [j k|j l]âŸ¨lÌƒ|kÌƒâŸ© - [k lÌƒ|kÌƒ l] + [k lÌƒ|l kÌƒ]                                     (i|i)âŸ¨lÌƒ|lÌƒâŸ© + (j|j)âŸ¨lÌƒ|lÌƒâŸ© + (k|k)âŸ¨lÌƒ|lÌƒâŸ© + (lÌƒ|lÌƒ) - G(i,j)âŸ¨lÌƒ|lÌƒâŸ© + F(i,j)âŸ¨lÌƒ|lÌƒâŸ© + â€¦ - G(i,lÌƒ) + F(i,lÌƒ) - G(j,lÌƒ) + F(j,lÌƒ) - G(k,lÌƒ) + F(k,lÌƒ)</code></pre><p>Finally, we derive the coupled integro-differential equation system for the continuum orbitals <code>kÌƒ</code>, <code>lÌƒ</code>:</p><pre><code class="language-julia-repl">julia&gt; eqs = diff(E, Conjugate.(continua))
EnergyExpressions.MCEquationSystem(EnergyExpressions.OrbitalEquation{Symbol,SparseArrays.SparseMatrixCSC{LinearCombinationEquation,Int64}}[OrbitalEquation(kÌƒ):
  [1, 1]  =  ğˆâ‚|kÌƒâŸ©(i|i) + ğˆâ‚|kÌƒâŸ©(j|j) + ğˆâ‚|kÌƒâŸ©(l|l) + hÌ‚|kÌƒâŸ© + ğˆâ‚|kÌƒâŸ©(- G(i,j)) + ğˆâ‚|kÌƒâŸ©F(i,j) + ğˆâ‚|kÌƒâŸ©(- G(i,l)) + ğˆâ‚|kÌƒâŸ©F(i,l) + ğˆâ‚|kÌƒâŸ©(- G(j,l)) + ğˆâ‚|kÌƒâŸ©F(j,l) + -[i|kÌƒ]|iâŸ© + [i|i]|kÌƒâŸ© + -[j|kÌƒ]|jâŸ© + [j|j]|kÌƒâŸ© + -[l|kÌƒ]|lâŸ© + [l|l]|kÌƒâŸ©
  [1, 2]  =  ğˆâ‚|lÌƒâŸ©(l|k) + ğˆâ‚|lÌƒâŸ©(- [i l|k i]) + ğˆâ‚|lÌƒâŸ©[i l|i k] + ğˆâ‚|lÌƒâŸ©(- [j l|k j]) + ğˆâ‚|lÌƒâŸ©[j l|j k] + -[l|lÌƒ]|kâŸ© + [l|k]|lÌƒâŸ©
, OrbitalEquation(lÌƒ):
  [2, 1]  =  ğˆâ‚|kÌƒâŸ©(k|l) + ğˆâ‚|kÌƒâŸ©(- [i k|l i]) + ğˆâ‚|kÌƒâŸ©[i k|i l] + ğˆâ‚|kÌƒâŸ©(- [j k|l j]) + ğˆâ‚|kÌƒâŸ©[j k|j l] + -[k|kÌƒ]|lâŸ© + [k|l]|kÌƒâŸ©
  [2, 2]  =  ğˆâ‚|lÌƒâŸ©(i|i) + ğˆâ‚|lÌƒâŸ©(j|j) + ğˆâ‚|lÌƒâŸ©(k|k) + hÌ‚|lÌƒâŸ© + ğˆâ‚|lÌƒâŸ©(- G(i,j)) + ğˆâ‚|lÌƒâŸ©F(i,j) + ğˆâ‚|lÌƒâŸ©(- G(i,k)) + ğˆâ‚|lÌƒâŸ©F(i,k) + ğˆâ‚|lÌƒâŸ©(- G(j,k)) + ğˆâ‚|lÌƒâŸ©F(j,k) + -[i|lÌƒ]|iâŸ© + [i|i]|lÌƒâŸ© + -[j|lÌƒ]|jâŸ© + [j|j]|lÌƒâŸ© + -[k|lÌƒ]|kâŸ© + [k|k]|lÌƒâŸ©
], Any[(i|i), ğˆâ‚, (j|j), (l|l), hÌ‚, G(i,j), F(i,j), G(i,l), F(i,l), G(j,l)  â€¦  [j k|l j], [j k|j l], [k|kÌƒ], [k|l], (k|k), G(i,k), F(i,k), G(j,k), F(j,k), [k|k]])</code></pre><p>We can investigate the <a href="#EnergyExpressions.MCEquationSystem"><code>MCEquationSystem</code></a> object <code>eqs</code> a bit. It consists of two coupled equations:</p><pre><code class="language-julia-repl">julia&gt; eqs.equations
2-element Array{EnergyExpressions.OrbitalEquation{Symbol,SparseArrays.SparseMatrixCSC{LinearCombinationEquation,Int64}},1}:
 OrbitalEquation(kÌƒ):
  [1, 1]  =  ğˆâ‚|kÌƒâŸ©(i|i) + ğˆâ‚|kÌƒâŸ©(j|j) + ğˆâ‚|kÌƒâŸ©(l|l) + hÌ‚|kÌƒâŸ© + ğˆâ‚|kÌƒâŸ©(- G(i,j)) + ğˆâ‚|kÌƒâŸ©F(i,j) + ğˆâ‚|kÌƒâŸ©(- G(i,l)) + ğˆâ‚|kÌƒâŸ©F(i,l) + ğˆâ‚|kÌƒâŸ©(- G(j,l)) + ğˆâ‚|kÌƒâŸ©F(j,l) + -[i|kÌƒ]|iâŸ© + [i|i]|kÌƒâŸ© + -[j|kÌƒ]|jâŸ© + [j|j]|kÌƒâŸ© + -[l|kÌƒ]|lâŸ© + [l|l]|kÌƒâŸ©
  [1, 2]  =  ğˆâ‚|lÌƒâŸ©(l|k) + ğˆâ‚|lÌƒâŸ©(- [i l|k i]) + ğˆâ‚|lÌƒâŸ©[i l|i k] + ğˆâ‚|lÌƒâŸ©(- [j l|k j]) + ğˆâ‚|lÌƒâŸ©[j l|j k] + -[l|lÌƒ]|kâŸ© + [l|k]|lÌƒâŸ©

 OrbitalEquation(lÌƒ):
  [2, 1]  =  ğˆâ‚|kÌƒâŸ©(k|l) + ğˆâ‚|kÌƒâŸ©(- [i k|l i]) + ğˆâ‚|kÌƒâŸ©[i k|i l] + ğˆâ‚|kÌƒâŸ©(- [j k|l j]) + ğˆâ‚|kÌƒâŸ©[j k|j l] + -[k|kÌƒ]|lâŸ© + [k|l]|kÌƒâŸ©
  [2, 2]  =  ğˆâ‚|lÌƒâŸ©(i|i) + ğˆâ‚|lÌƒâŸ©(j|j) + ğˆâ‚|lÌƒâŸ©(k|k) + hÌ‚|lÌƒâŸ© + ğˆâ‚|lÌƒâŸ©(- G(i,j)) + ğˆâ‚|lÌƒâŸ©F(i,j) + ğˆâ‚|lÌƒâŸ©(- G(i,k)) + ğˆâ‚|lÌƒâŸ©F(i,k) + ğˆâ‚|lÌƒâŸ©(- G(j,k)) + ğˆâ‚|lÌƒâŸ©F(j,k) + -[i|lÌƒ]|iâŸ© + [i|i]|lÌƒâŸ© + -[j|lÌƒ]|jâŸ© + [j|j]|lÌƒâŸ© + -[k|lÌƒ]|kâŸ© + [k|k]|lÌƒâŸ©</code></pre><p>The first equation consists of the following terms:</p><pre><code class="language-julia-repl">julia&gt; eqs.equations[1].one_body
0-element Array{EnergyExpressions.MCCoeff,1}

julia&gt; eqs.equations[1].direct_terms
3-element Array{Pair{Int64,Array{EnergyExpressions.MCCoeff,1}},1}:
 13 =&gt; [MCCoeff{Int64}(1, 1, 1, Int64[])]
 14 =&gt; [MCCoeff{Int64}(1, 1, 1, Int64[])]
 12 =&gt; [MCCoeff{Int64}(1, 1, 1, Int64[])]

julia&gt; eqs.equations[1].exchange_terms
3-element Array{Tuple{Any,EnergyExpressions.MCCoeff,Any},1}:
 ([i|kÌƒ], EnergyExpressions.MCCoeff{Int64}(1, 1, -1, Int64[]), :i)
 ([j|kÌƒ], EnergyExpressions.MCCoeff{Int64}(1, 1, -1, Int64[]), :j)
 ([l|kÌƒ], EnergyExpressions.MCCoeff{Int64}(1, 1, -1, Int64[]), :l)

julia&gt; eqs.equations[1].source_terms
4-element Array{Pair{Int64,Array{Tuple{EnergyExpressions.MCCoeff,Any},1}},1}:
  2 =&gt; [(MCCoeff{Int64}(1, 1, 1, [1]), :kÌƒ), (MCCoeff{Int64}(1, 1, 1, [3]), :kÌƒ), (MCCoeff{Int64}(1, 1, 1, [4]), :kÌƒ), (MCCoeff{Int64}(1, 1, -1, [6]), :kÌƒ), (MCCoeff{Int64}(1, 1, 1, [7]), :kÌƒ), (MCCoeff{Int64}(1, 1, -1, [8]), :kÌƒ), (MCCoeff{Int64}(1, 1, 1, [9]), :kÌƒ), (MCCoeff{Int64}(1, 1, -1, [10]), :kÌƒ), (MCCoeff{Int64}(1, 1, 1, [11]), :kÌƒ), (MCCoeff{Int64}(1, 2, 1, [15]), :lÌƒ), (MCCoeff{Int64}(1, 2, -1, [16]), :lÌƒ), (MCCoeff{Int64}(1, 2, 1, [17]), :lÌƒ), (MCCoeff{Int64}(1, 2, -1, [18]), :lÌƒ), (MCCoeff{Int64}(1, 2, 1, [19]), :lÌƒ)]
  5 =&gt; [(MCCoeff{Int64}(1, 1, 1, Int64[]), :kÌƒ)]
 21 =&gt; [(MCCoeff{Int64}(1, 2, 1, Int64[]), :lÌƒ)]
 20 =&gt; [(MCCoeff{Int64}(1, 2, -1, Int64[]), :k)]</code></pre><p>where the <a href="#EnergyExpressions.MCCoeff"><code>MCCoeff</code></a> objects indicate which components of the mixing coefficient vector <span>$\vec{c}$</span> need to be multiplied, and all the integers are pointers to the list of common integrals:</p><pre><code class="language-julia-repl">julia&gt; eqs.integrals
34-element Array{Any,1}:
 (i|i)
 ğˆâ‚
 (j|j)
 (l|l)
 hÌ‚
 G(i,j)
 F(i,j)
 G(i,l)
 F(i,l)
 G(j,l)
 F(j,l)
 [i|i]
 [j|j]
 [l|l]
 (l|k)
 [i l|k i]
 [i l|i k]
 [j l|k j]
 [j l|j k]
 [l|lÌƒ]
 [l|k]
 (k|l)
 [i k|l i]
 [i k|i l]
 [j k|l j]
 [j k|j l]
 [k|kÌƒ]
 [k|l]
 (k|k)
 G(i,k)
 F(i,k)
 G(j,k)
 F(j,k)
 [k|k]</code></pre><p>From this we see that the <code>ğˆâ‚</code> (one-body identity operator) contribution to <code>|kÌƒâŸ©</code> can be written as a linear combination of <code>|kÌƒâŸ©</code> and <code>|lÌƒâŸ©</code>, weighted by different components of the mixing coefficient vector <span>$\vec{c}$</span> and various other integrals. This is all the information necessary to set up an efficient equation solver.</p><h2><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.MCCoeff" href="#EnergyExpressions.MCCoeff"><code>EnergyExpressions.MCCoeff</code></a> â€” <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MCCoeff(i, j, coeff, integrals=[])</code></pre><p>Represents the coefficient of one term in the multi-configurational expansion. <code>i</code> and <code>j</code> are indices in the mixing-coefficient vector c (which is subject to optimization, and thus has to be referred to), <code>coeff</code> is an additional coefficient, and <code>integrals</code> is a list of indices into the vector of common integrals, the values of which should be multiplied to form the overall coefficient.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/7c522142f3f36916ea213d0f8d91760ca6d26c6d/src/multi_configurational_equations.jl#L1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.OrbitalEquation" href="#EnergyExpressions.OrbitalEquation"><code>EnergyExpressions.OrbitalEquation</code></a> â€” <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">OrbitalEquation(orbital, equation,
                one_body, direct_terms, exchange_terms, source_terms)</code></pre><p>Represents the integro-differential equation for <code>orbital</code>, expressed as a linear combination of the different terms, with pointers to the list of common integrals that is stored by the encompassing <a href="#EnergyExpressions.MCEquationSystem"><code>MCEquationSystem</code></a> object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/7c522142f3f36916ea213d0f8d91760ca6d26c6d/src/multi_configurational_equations.jl#L18-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.MCEquationSystem" href="#EnergyExpressions.MCEquationSystem"><code>EnergyExpressions.MCEquationSystem</code></a> â€” <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MCEquationSystem(equations, integrals)</code></pre><p>Represents a coupled system of integro-differential <code>equations</code>, resulting from the variation of a multi-configurational <a href="@ref"><code>EnergyExpression</code></a>, with respect to all constituent orbitals. All <code>integrals</code> that are in common between the <code>equations</code> need only be computed once per iteration, for efficiency.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/7c522142f3f36916ea213d0f8d91760ca6d26c6d/src/multi_configurational_equations.jl#L42-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.pushifmissing!" href="#EnergyExpressions.pushifmissing!"><code>EnergyExpressions.pushifmissing!</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pushifmissing!(vector, element)</code></pre><p>Push <code>element</code> to the end of <code>vector</code>, if not already present. Returns the index of <code>element</code> in <code>vector</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/7c522142f3f36916ea213d0f8d91760ca6d26c6d/src/multi_configurational_equations.jl#L56-L61">source</a></section><footer><hr/><a class="previous" href="../variations/"><span class="direction">Previous</span><span class="title">Variation</span></a></footer></article></body></html>
