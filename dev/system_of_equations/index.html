<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>System of equations Â· EnergyExpressions</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script src="../assets/latex.js"></script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.svg" alt="EnergyExpressions logo"/></a><h1>EnergyExpressions</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Theory</span><ul><li><a class="toctext" href="../notation/">Notation</a></li><li><a class="toctext" href="../energy_expressions/">Energy Expressions</a></li><li><a class="toctext" href="../calculus_of_variations/">Calculus of Variations</a></li></ul></li><li><span class="toctext">Implementation</span><ul><li><a class="toctext" href="../conjugate_orbitals/">Conjugate orbitals</a></li><li><a class="toctext" href="../slater_determinants/">Slater determinants</a></li><li><a class="toctext" href="../nbody_operators/">N-body operators</a></li><li><a class="toctext" href="../nbody_matrix_elements/">N-body matrix elements</a></li><li><a class="toctext" href="../common_operators/">Common N-body operators</a></li><li><a class="toctext" href="../equations/">N-body equations</a></li><li><a class="toctext" href="../variations/">Variation</a></li><li class="current"><a class="toctext" href>System of equations</a><ul class="internal"><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Implementation-1">Implementation</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Implementation</li><li><a href>System of equations</a></li></ul><a class="edit-page" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/master/docs/src/system_of_equations.md"><span class="fa">ï‚›</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>System of equations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="System-of-equations-1" href="#System-of-equations-1">System of equations</a></h1><p>When dealing with large energy expressions resulting from many configurations, when deriving the orbital equations (see <a href="../equations/#N-body-equations-1">N-body equations</a> and <a href="../variations/#Calculus-of-Variations-â€“-Implementation-1">Calculus of Variations â€“ Implementation</a>), many of the integrals involved will be shared between the different terms of the equations. It is therefore of interest to gather a list of integrals that can be calculated once at every iteration (in a self-consistent procedure for finding eigenstates, or in time-propagation), and whose values can then be reused when solving the individual equations. The routines described below, although primitive, aid in this effort.</p><p>The idea is the following: With an energy expression on the form</p><div>\[\begin{equation}
E(\vec{P},\vec{c}) = \frac{\vec{c}^H
\mat{H}\vec{c}}{\vec{c}^H\vec{c}}
\end{equation}\]</div><p>where <span>$\vec{P}$</span> is a set of orbitals, <span>$\vec{c}$</span> is a vector of mixing coefficients, and</p><div>\[\begin{equation}
\mat{H}_{ij} \defd \matrixel{\chi_i}{\Hamiltonian}{\chi_j},
\end{equation}\]</div><p>all terms of the equations can be written on the form</p><div>\[\begin{equation}
\label{eqn:equation-term}
\operator{A}\ket{\chi}
\underbrace{\left[
\sum_n \alpha_n \conj{c}_{i_n} c_{j_n}
\prod_k \int_{n_k}
\right]}_{\textrm{Rank 0}},
\end{equation}\]</div><p>(or on its dual form with conjugated orbitals) where <span>$\operator{A}$</span> is some one-body operator, <span>$\alpha_n$</span> a coefficient due to the energy expression, <span>$\conj{c}_{i_n} c_{j_n}$</span> the coefficient due to the multi-configurational expansion, and finally <span>$\int_{n_k}$</span> all the extra integrals (which are necessarily zero-body operators) that may appear due to non-orthogonal orbitals (and which may be shared between many equations). The operator <span>$\operator{A}$</span> can have ranks 0â€“2; formally, it can only have rank 0 (multiplication by a scalar) or 2 (multiplication by a matrix). What we somewhat sloppily to refer by â€œrank 1â€ is an operator of rank 2, but which is diagonal in the underlying coordinate, such as a local potential.</p><p>Thus, to efficiently perform an iteration, one would first compute all common integrals <span>$\int_k$</span>, and then for every equation term of the form <span>$\eqref{eqn:equation-term}$</span>, form the coefficient in the brakets, calculate the action of the operator <span>$\operator{A}$</span> on the orbital <span>$\chi$</span>, multiplied the coefficient.</p><p>There are a few important special cases of <span>$\eqref{eqn:equation-term}$</span>:</p><ol><li><p>Field-free, one-body Hamiltonian, i.e. <span>$\operator{A}=\hamiltonian_0$</span>. This is the contribution from the orbital <span>$\ket{\chi}$</span> to itself. Rank 2.</p></li><li><p>One-body Hamiltonian, including field, i.e. <span>$\operator{A}=\hamiltonian$</span>. This is the contribution from another orbital <span>$\ket{\chi&#39;}$</span> to <span>$\ket{\chi}$</span> via some off-diagonal coupling, such as an external field (e.g. an electroâ€“magnetic field). Rank 2.</p></li><li><p>Direct interaction, i.e. <span>$\operator{A}=\direct{kl}$</span>, where two other orbitals <span>$\ket{\chi_k}$</span> and <span>$\ket{\chi_l}$</span> together form a potential acting on <span>$\ket{\chi}$</span>. â€œRank 1â€.</p></li><li><p>Exchange interaction, i.e. <span>$\operator{A}=\exchange{kl}$</span>, where another orbital <span>$\ket{\chi_k}$</span> and <span>$\ket{\chi}$</span> together form a potential acting on a third orbital <span>$\ket{\chi_l}$</span>. Rank 2.</p></li><li><p>Source term, i.e. a contribution that does not involve <span>$\ket{\chi}$</span> in any way. This term arises from other configurations in the multi-configurational expansion. Case 2. is also formulated in this way. Rank 0â€“2. If for some reason the source orbital and/or the operator acting on it is fixed, it may be possible to precompute the effect of the operator on the source orbital and reduce the computational complexity to a rank 0-equivalent operation.</p></li></ol><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>We start by defining a set of configurations and specifying that a few of the constituent orbitals are non-orthogonal:</p><pre><code class="language-julia-repl">julia&gt; cfgs = [[:i, :j, :l, :kÌƒ], [:i, :j, :k, :lÌƒ]]
2-element Array{Array{Symbol,1},1}:
 [:i, :j, :l, :kÌƒ]
 [:i, :j, :k, :lÌƒ]

julia&gt; continua = [:kÌƒ, :lÌƒ]
2-element Array{Symbol,1}:
 :kÌƒ
 :lÌƒ

julia&gt; overlaps = [OrbitalOverlap(i,j) for i in continua for j in continua]
4-element Array{OrbitalOverlap{Symbol,Symbol},1}:
 âŸ¨kÌƒ|kÌƒâŸ©
 âŸ¨kÌƒ|lÌƒâŸ©
 âŸ¨lÌƒ|kÌƒâŸ©
 âŸ¨lÌƒ|lÌƒâŸ©</code></pre><p>We then set up the energy expression as before:</p><pre><code class="language-julia-repl">julia&gt; H = OneBodyHamiltonian() + CoulombInteraction()
hÌ‚ + gÌ‚

julia&gt; E = Matrix(H, SlaterDeterminant.(cfgs), overlaps)
2Ã—2 Array{EnergyExpressions.NBodyMatrixElement,2}:
 (i|i)âŸ¨kÌƒ|kÌƒâŸ© + (j|j)âŸ¨kÌƒ|kÌƒâŸ© + (l|l)âŸ¨kÌƒ|kÌƒâŸ© + (kÌƒ|kÌƒ) - G(i,j)âŸ¨kÌƒ|kÌƒâŸ© + F(i,j)âŸ¨kÌƒ|kÌƒâŸ© + â€¦ - G(i,kÌƒ) + F(i,kÌƒ) - G(j,kÌƒ) + F(j,kÌƒ) - G(l,kÌƒ) + F(l,kÌƒ)  â€¦  (l|k)âŸ¨kÌƒ|lÌƒâŸ© - [i l|k i]âŸ¨kÌƒ|lÌƒâŸ© + [i l|i k]âŸ¨kÌƒ|lÌƒâŸ© - [j l|k j]âŸ¨kÌƒ|lÌƒâŸ© + [j l|j k]âŸ¨kÌƒ|lÌƒâŸ© - [l kÌƒ|lÌƒ k] + [l kÌƒ|k lÌƒ]
 (k|l)âŸ¨lÌƒ|kÌƒâŸ© - [i k|l i]âŸ¨lÌƒ|kÌƒâŸ© + [i k|i l]âŸ¨lÌƒ|kÌƒâŸ© - [j k|l j]âŸ¨lÌƒ|kÌƒâŸ© + [j k|j l]âŸ¨lÌƒ|kÌƒâŸ© - [k lÌƒ|kÌƒ l] + [k lÌƒ|l kÌƒ]                                     (i|i)âŸ¨lÌƒ|lÌƒâŸ© + (j|j)âŸ¨lÌƒ|lÌƒâŸ© + (k|k)âŸ¨lÌƒ|lÌƒâŸ© + (lÌƒ|lÌƒ) - G(i,j)âŸ¨lÌƒ|lÌƒâŸ© + F(i,j)âŸ¨lÌƒ|lÌƒâŸ© + â€¦ - G(i,lÌƒ) + F(i,lÌƒ) - G(j,lÌƒ) + F(j,lÌƒ) - G(k,lÌƒ) + F(k,lÌƒ)</code></pre><p>Finally, we derive the coupled integro-differential equation system for the continuum orbitals <code>kÌƒ</code>, <code>lÌƒ</code>:</p><pre><code class="language-julia-repl">julia&gt; eqs = diff(E, Conjugate.(continua))
EnergyExpressions.MCEquationSystem(EnergyExpressions.OrbitalEquation{Symbol,SparseArrays.SparseMatrixCSC{LinearCombinationEquation,Int64}}[OrbitalEquation(kÌƒ):
  [1, 1]  =  + (i|i)ğˆâ‚|kÌƒâŸ© + (j|j)ğˆâ‚|kÌƒâŸ© + (l|l)ğˆâ‚|kÌƒâŸ© + hÌ‚|kÌƒâŸ© - G(i,j)ğˆâ‚|kÌƒâŸ© + F(i,j)ğˆâ‚|kÌƒâŸ© - G(i,l)ğˆâ‚|kÌƒâŸ© + F(i,l)ğˆâ‚|kÌƒâŸ© - G(j,l)ğˆâ‚|kÌƒâŸ© + F(j,l)ğˆâ‚|kÌƒâŸ© - [i|kÌƒ]|iâŸ© + [i|i]|kÌƒâŸ© - [j|kÌƒ]|jâŸ© + [j|j]|kÌƒâŸ© - [l|kÌƒ]|lâŸ© + [l|l]|kÌƒâŸ©
  [1, 2]  =  + (l|k)ğˆâ‚|lÌƒâŸ© - [i l|k i]ğˆâ‚|lÌƒâŸ© + [i l|i k]ğˆâ‚|lÌƒâŸ© - [j l|k j]ğˆâ‚|lÌƒâŸ© + [j l|j k]ğˆâ‚|lÌƒâŸ© - [l|lÌƒ]|kâŸ© + [l|k]|lÌƒâŸ©
, OrbitalEquation(lÌƒ):
  [2, 1]  =  + (k|l)ğˆâ‚|kÌƒâŸ© - [i k|l i]ğˆâ‚|kÌƒâŸ© + [i k|i l]ğˆâ‚|kÌƒâŸ© - [j k|l j]ğˆâ‚|kÌƒâŸ© + [j k|j l]ğˆâ‚|kÌƒâŸ© - [k|kÌƒ]|lâŸ© + [k|l]|kÌƒâŸ©
  [2, 2]  =  + (i|i)ğˆâ‚|lÌƒâŸ© + (j|j)ğˆâ‚|lÌƒâŸ© + (k|k)ğˆâ‚|lÌƒâŸ© + hÌ‚|lÌƒâŸ© - G(i,j)ğˆâ‚|lÌƒâŸ© + F(i,j)ğˆâ‚|lÌƒâŸ© - G(i,k)ğˆâ‚|lÌƒâŸ© + F(i,k)ğˆâ‚|lÌƒâŸ© - G(j,k)ğˆâ‚|lÌƒâŸ© + F(j,k)ğˆâ‚|lÌƒâŸ© - [i|lÌƒ]|iâŸ© + [i|i]|lÌƒâŸ© - [j|lÌƒ]|jâŸ© + [j|j]|lÌƒâŸ© - [k|lÌƒ]|kâŸ© + [k|k]|lÌƒâŸ©
], Any[(i|i), (j|j), (l|l), G(i,j), F(i,j), G(i,l), F(i,l), G(j,l), F(j,l), [i|i]  â€¦  [j k|l j], [j k|j l], [k|kÌƒ], [k|l], (k|k), G(i,k), F(i,k), G(j,k), F(j,k), [k|k]])</code></pre><p>We can investigate the <a href="#EnergyExpressions.MCEquationSystem"><code>MCEquationSystem</code></a> object <code>eqs</code> a bit. It consists of two coupled equations:</p><pre><code class="language-julia-repl">julia&gt; eqs.equations
2-element Array{EnergyExpressions.OrbitalEquation{Symbol,SparseArrays.SparseMatrixCSC{LinearCombinationEquation,Int64}},1}:
 OrbitalEquation(kÌƒ):
  [1, 1]  =  + (i|i)ğˆâ‚|kÌƒâŸ© + (j|j)ğˆâ‚|kÌƒâŸ© + (l|l)ğˆâ‚|kÌƒâŸ© + hÌ‚|kÌƒâŸ© - G(i,j)ğˆâ‚|kÌƒâŸ© + F(i,j)ğˆâ‚|kÌƒâŸ© - G(i,l)ğˆâ‚|kÌƒâŸ© + F(i,l)ğˆâ‚|kÌƒâŸ© - G(j,l)ğˆâ‚|kÌƒâŸ© + F(j,l)ğˆâ‚|kÌƒâŸ© - [i|kÌƒ]|iâŸ© + [i|i]|kÌƒâŸ© - [j|kÌƒ]|jâŸ© + [j|j]|kÌƒâŸ© - [l|kÌƒ]|lâŸ© + [l|l]|kÌƒâŸ©
  [1, 2]  =  + (l|k)ğˆâ‚|lÌƒâŸ© - [i l|k i]ğˆâ‚|lÌƒâŸ© + [i l|i k]ğˆâ‚|lÌƒâŸ© - [j l|k j]ğˆâ‚|lÌƒâŸ© + [j l|j k]ğˆâ‚|lÌƒâŸ© - [l|lÌƒ]|kâŸ© + [l|k]|lÌƒâŸ©

 OrbitalEquation(lÌƒ):
  [2, 1]  =  + (k|l)ğˆâ‚|kÌƒâŸ© - [i k|l i]ğˆâ‚|kÌƒâŸ© + [i k|i l]ğˆâ‚|kÌƒâŸ© - [j k|l j]ğˆâ‚|kÌƒâŸ© + [j k|j l]ğˆâ‚|kÌƒâŸ© - [k|kÌƒ]|lâŸ© + [k|l]|kÌƒâŸ©
  [2, 2]  =  + (i|i)ğˆâ‚|lÌƒâŸ© + (j|j)ğˆâ‚|lÌƒâŸ© + (k|k)ğˆâ‚|lÌƒâŸ© + hÌ‚|lÌƒâŸ© - G(i,j)ğˆâ‚|lÌƒâŸ© + F(i,j)ğˆâ‚|lÌƒâŸ© - G(i,k)ğˆâ‚|lÌƒâŸ© + F(i,k)ğˆâ‚|lÌƒâŸ© - G(j,k)ğˆâ‚|lÌƒâŸ© + F(j,k)ğˆâ‚|lÌƒâŸ© - [i|lÌƒ]|iâŸ© + [i|i]|lÌƒâŸ© - [j|lÌƒ]|jâŸ© + [j|j]|lÌƒâŸ© - [k|lÌƒ]|kâŸ© + [k|k]|lÌƒâŸ©</code></pre><p>The first equation consists of the following terms:</p><pre><code class="language-julia-repl">julia&gt; eqs.equations[1].terms
6-element Array{Pair{Int64,Array{EnergyExpressions.MCTerm,1}},1}:
  0 =&gt; [MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, ğˆâ‚, :kÌƒ, [1]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, ğˆâ‚, :kÌƒ, [2]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, ğˆâ‚, :kÌƒ, [3]), MCTerm{Int64,OneBodyHamiltonian,Symbol}(1, 1, 1, hÌ‚, :kÌƒ, Int64[]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, -1, ğˆâ‚, :kÌƒ, [4]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, ğˆâ‚, :kÌƒ, [5]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, -1, ğˆâ‚, :kÌƒ, [6]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, ğˆâ‚, :kÌƒ, [7]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, -1, ğˆâ‚, :kÌƒ, [8]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, ğˆâ‚, :kÌƒ, [9]), MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, -1, [i|kÌƒ], :i, Int64[]), MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, -1, [j|kÌƒ], :j, Int64[]), MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, -1, [l|kÌƒ], :l, Int64[]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 2, 1, ğˆâ‚, :lÌƒ, [13]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 2, -1, ğˆâ‚, :lÌƒ, [14]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 2, 1, ğˆâ‚, :lÌƒ, [15]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 2, -1, ğˆâ‚, :lÌƒ, [16]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 2, 1, ğˆâ‚, :lÌƒ, [17])]
 10 =&gt; [MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, 1, [i|i], :kÌƒ, Int64[])]
 19 =&gt; [MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 2, 1, [l|k], :lÌƒ, Int64[])]
 11 =&gt; [MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, 1, [j|j], :kÌƒ, Int64[])]
 12 =&gt; [MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, 1, [l|l], :kÌƒ, Int64[])]
 18 =&gt; [MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 2, -1, [l|lÌƒ], :k, Int64[])]</code></pre><p>where the <a href="#EnergyExpressions.MCTerm"><code>MCTerm</code></a> objects indicate which components of the mixing coefficient vector <span>$\vec{c}$</span> need to be multiplied, and all the integers are pointers to the list of common integrals:</p><pre><code class="language-julia-repl">julia&gt; eqs.integrals
32-element Array{Any,1}:
 (i|i)
 (j|j)
 (l|l)
 G(i,j)
 F(i,j)
 G(i,l)
 F(i,l)
 G(j,l)
 F(j,l)
 [i|i]
 [j|j]
 [l|l]
 (l|k)
 [i l|k i]
 [i l|i k]
 [j l|k j]
 [j l|j k]
 [l|lÌƒ]
 [l|k]
 (k|l)
 [i k|l i]
 [i k|i l]
 [j k|l j]
 [j k|j l]
 [k|kÌƒ]
 [k|l]
 (k|k)
 G(i,k)
 F(i,k)
 G(j,k)
 F(j,k)
 [k|k]</code></pre><p>From this we see that the <code>ğˆâ‚</code> (one-body identity operator) contribution to <code>|kÌƒâŸ©</code> can be written as a linear combination of <code>|kÌƒâŸ©</code> and <code>|lÌƒâŸ©</code>, weighted by different components of the mixing coefficient vector <span>$\vec{c}$</span> and various other integrals. This is all the information necessary to set up an efficient equation solver.</p><h2><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.MCTerm" href="#EnergyExpressions.MCTerm"><code>EnergyExpressions.MCTerm</code></a> â€” <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MCTerm(i, j, coeff, operator, source_orbital, integrals=[])</code></pre><p>Represents one term in the multi-configurational expansion. <code>i</code> and <code>j</code> are indices in the mixing-coefficient vector c (which is subject to optimization, and thus has to be referred to), <code>coeff</code> is an additional coefficient, and <code>integrals</code> is a list of indices into the vector of common integrals, the values of which should be multiplied to form the overall coefficient.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aeb9a5f4322cc28aee26840f1b0f6fc9c86371d3/src/multi_configurational_equations.jl#L1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.OrbitalEquation" href="#EnergyExpressions.OrbitalEquation"><code>EnergyExpressions.OrbitalEquation</code></a> â€” <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OrbitalEquation(orbital, equation,
                one_body, direct_terms, exchange_terms, source_terms)</code></pre><p>Represents the integro-differential equation for <code>orbital</code>, expressed as a linear combination of the different terms, with pointers to the list of common integrals that is stored by the encompassing <a href="#EnergyExpressions.MCEquationSystem"><code>MCEquationSystem</code></a> object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aeb9a5f4322cc28aee26840f1b0f6fc9c86371d3/src/multi_configurational_equations.jl#L20-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.orbital_equation" href="#EnergyExpressions.orbital_equation"><code>EnergyExpressions.orbital_equation</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">orbital_equation(E::EnergyExpression, orbital, integrals::Vector)</code></pre><p>Generate the <a href="#EnergyExpressions.OrbitalEquation"><code>OrbitalEquation</code></a> governing <code>orbital</code> by varying the <a href="../nbody_matrix_elements/#EnergyExpressions.EnergyExpression"><code>EnergyExpression</code></a> <code>E</code>, and storing common expressions in <code>integrals</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aeb9a5f4322cc28aee26840f1b0f6fc9c86371d3/src/multi_configurational_equations.jl#L68-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.MCEquationSystem" href="#EnergyExpressions.MCEquationSystem"><code>EnergyExpressions.MCEquationSystem</code></a> â€” <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MCEquationSystem(equations, integrals)</code></pre><p>Represents a coupled system of integro-differential <code>equations</code>, resulting from the variation of a multi-configurational <a href="../nbody_matrix_elements/#EnergyExpressions.EnergyExpression"><code>EnergyExpression</code></a>, with respect to all constituent orbitals. All <code>integrals</code> that are in common between the <code>equations</code> need only be computed once per iteration, for efficiency.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aeb9a5f4322cc28aee26840f1b0f6fc9c86371d3/src/multi_configurational_equations.jl#L41-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.pushifmissing!" href="#EnergyExpressions.pushifmissing!"><code>EnergyExpressions.pushifmissing!</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pushifmissing!(vector, element)</code></pre><p>Push <code>element</code> to the end of <code>vector</code>, if not already present. Returns the index of <code>element</code> in <code>vector</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aeb9a5f4322cc28aee26840f1b0f6fc9c86371d3/src/multi_configurational_equations.jl#L55-L60">source</a></section><footer><hr/><a class="previous" href="../variations/"><span class="direction">Previous</span><span class="title">Variation</span></a></footer></article></body></html>
