<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>System of equations · EnergyExpressions</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script src="../assets/latex.js"></script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.svg" alt="EnergyExpressions logo"/></a><h1>EnergyExpressions</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Theory</span><ul><li><a class="toctext" href="../notation/">Notation</a></li><li><a class="toctext" href="../energy_expressions/">Energy Expressions</a></li><li><a class="toctext" href="../calculus_of_variations/">Calculus of Variations</a></li></ul></li><li><span class="toctext">Implementation</span><ul><li><a class="toctext" href="../conjugate_orbitals/">Conjugate orbitals</a></li><li><a class="toctext" href="../slater_determinants/">Slater determinants</a></li><li><a class="toctext" href="../nbody_operators/">N-body operators</a></li><li><a class="toctext" href="../nbody_matrix_elements/">N-body matrix elements</a></li><li><a class="toctext" href="../common_operators/">Common N-body operators</a></li><li><a class="toctext" href="../equations/">N-body equations</a></li><li><a class="toctext" href="../variations/">Variation</a></li><li class="current"><a class="toctext" href>System of equations</a><ul class="internal"><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Implementation-1">Implementation</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Implementation</li><li><a href>System of equations</a></li></ul><a class="edit-page" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/master/docs/src/system_of_equations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>System of equations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="System-of-equations-1" href="#System-of-equations-1">System of equations</a></h1><p>When dealing with large energy expressions resulting from many configurations, when deriving the orbital equations (see <a href="@ref"><code>N-body equations</code></a> and <a href="@ref"><code>Calculus of Variations – Implementation</code></a>), many of the integrals involved will be shared between the different terms of the equations. It is therefore of interest to gather a list of integrals that can be calculated once at every iteration (in a self-consistent procedure for finding eigenstates, or in time-propagation), and whose values can then be reused when solving the individual equations. The routines described below, although primitive, aid in this effort.</p><p>The idea is the following: With an energy expression on the form</p><div>\[\begin{equation}
E(\vec{P},\vec{c}) = \frac{\vec{c}^H
\mat{H}\vec{c}}{\vec{c}^H\vec{c}}
\end{equation}\]</div><p>where <span>$\vec{P}$</span> is a set of orbitals, <span>$\vec{c}$</span> is a vector of mixing coefficients, and</p><div>\[\begin{equation}
\mat{H}_{ij} \defd \matrixel{\chi_i}{\Hamiltonian}{\chi_j},
\end{equation}\]</div><p>all terms of the equations can be written on the form</p><div>\[\begin{equation}
\label{eqn:equation-term}
\operator{A}\ket{\chi}
\underbrace{\left[
\sum_n \alpha_n \conj{c}_{i_n} c_{j_n}
\prod_k \int_{n_k}
\right]}_{\textrm{Rank 0}},
\end{equation}\]</div><p>(or on its dual form with conjugated orbitals) where <span>$\operator{A}$</span> is some one-body operator, <span>$\alpha_n$</span> a coefficient due to the energy expression, <span>$\conj{c}_{i_n} c_{j_n}$</span> the coefficient due to the multi-configurational expansion, and finally <span>$\int_{n_k}$</span> all the extra integrals (which are necessarily zero-body operators) that may appear due to non-orthogonal orbitals (and which may be shared between many equations). The operator <span>$\operator{A}$</span> can have ranks 0–2; formally, it can only have rank 0 (multiplication by a scalar) or 2 (multiplication by a matrix). What we somewhat sloppily to refer by “rank 1” is an operator of rank 2, but which is diagonal in the underlying coordinate, such as a local potential.</p><p>Thus, to efficiently perform an iteration, one would first compute all common integrals <span>$\int_k$</span>, and then for every equation term of the form <span>$\eqref{eqn:equation-term}$</span>, form the coefficient in the brakets, calculate the action of the operator <span>$\operator{A}$</span> on the orbital <span>$\chi$</span>, multiplied the coefficient.</p><p>There are a few important special cases of <span>$\eqref{eqn:equation-term}$</span>:</p><ol><li><p>Field-free, one-body Hamiltonian, i.e. <span>$\operator{A}=\hamiltonian_0$</span>. This is the contribution from the orbital <span>$\ket{\chi}$</span> to itself. Rank 2.</p></li><li><p>One-body Hamiltonian, including field, i.e. <span>$\operator{A}=\hamiltonian$</span>. This is the contribution from another orbital <span>$\ket{\chi&#39;}$</span> to <span>$\ket{\chi}$</span> via some off-diagonal coupling, such as an external field (e.g. an electro–magnetic field). Rank 2.</p></li><li><p>Direct interaction, i.e. <span>$\operator{A}=\direct{kl}$</span>, where two other orbitals <span>$\ket{\chi_k}$</span> and <span>$\ket{\chi_l}$</span> together form a potential acting on <span>$\ket{\chi}$</span>. “Rank 1”.</p></li><li><p>Exchange interaction, i.e. <span>$\operator{A}=\exchange{kl}$</span>, where another orbital <span>$\ket{\chi_k}$</span> and <span>$\ket{\chi}$</span> together form a potential acting on a third orbital <span>$\ket{\chi_l}$</span>. Rank 2.</p></li><li><p>Source term, i.e. a contribution that does not involve <span>$\ket{\chi}$</span> in any way. This term arises from other configurations in the multi-configurational expansion. Case 2. is also formulated in this way. Rank 0–2. If for some reason the source orbital and/or the operator acting on it is fixed, it may be possible to precompute the effect of the operator on the source orbital and reduce the computational complexity to a rank 0-equivalent operation.</p></li></ol><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>We start by defining a set of configurations and specifying that a few of the constituent orbitals are non-orthogonal:</p><pre><code class="language-julia-repl">julia&gt; cfgs = [[:i, :j, :l, :k̃], [:i, :j, :k, :l̃]]
2-element Array{Array{Symbol,1},1}:
 [:i, :j, :l, :k̃]
 [:i, :j, :k, :l̃]

julia&gt; continua = [:k̃, :l̃]
2-element Array{Symbol,1}:
 :k̃
 :l̃

julia&gt; overlaps = [OrbitalOverlap(i,j) for i in continua for j in continua]
4-element Array{OrbitalOverlap{Symbol,Symbol},1}:
 ⟨k̃|k̃⟩
 ⟨k̃|l̃⟩
 ⟨l̃|k̃⟩
 ⟨l̃|l̃⟩</code></pre><p>We then set up the energy expression as before:</p><pre><code class="language-julia-repl">julia&gt; H = OneBodyHamiltonian() + CoulombInteraction()
ĥ + ĝ

julia&gt; E = Matrix(H, SlaterDeterminant.(cfgs), overlaps)
2×2 Array{EnergyExpressions.NBodyMatrixElement,2}:
 (i|i)⟨k̃|k̃⟩ + (j|j)⟨k̃|k̃⟩ + (l|l)⟨k̃|k̃⟩ + (k̃|k̃) - G(i,j)⟨k̃|k̃⟩ + F(i,j)⟨k̃|k̃⟩ + … - G(i,k̃) + F(i,k̃) - G(j,k̃) + F(j,k̃) - G(l,k̃) + F(l,k̃)  …  (l|k)⟨k̃|l̃⟩ - [i l|k i]⟨k̃|l̃⟩ + [i l|i k]⟨k̃|l̃⟩ - [j l|k j]⟨k̃|l̃⟩ + [j l|j k]⟨k̃|l̃⟩ - [l k̃|l̃ k] + [l k̃|k l̃]
 (k|l)⟨l̃|k̃⟩ - [i k|l i]⟨l̃|k̃⟩ + [i k|i l]⟨l̃|k̃⟩ - [j k|l j]⟨l̃|k̃⟩ + [j k|j l]⟨l̃|k̃⟩ - [k l̃|k̃ l] + [k l̃|l k̃]                                     (i|i)⟨l̃|l̃⟩ + (j|j)⟨l̃|l̃⟩ + (k|k)⟨l̃|l̃⟩ + (l̃|l̃) - G(i,j)⟨l̃|l̃⟩ + F(i,j)⟨l̃|l̃⟩ + … - G(i,l̃) + F(i,l̃) - G(j,l̃) + F(j,l̃) - G(k,l̃) + F(k,l̃)</code></pre><p>Finally, we derive the coupled integro-differential equation system for the continuum orbitals <code>k̃</code>, <code>l̃</code>:</p><pre><code class="language-julia-repl">julia&gt; eqs = diff(E, Conjugate.(continua))
EnergyExpressions.MCEquationSystem(EnergyExpressions.OrbitalEquation{Symbol,SparseArrays.SparseMatrixCSC{LinearCombinationEquation,Int64}}[OrbitalEquation(k̃):
  [1, 1]  =  𝐈₁|k̃⟩(i|i) + 𝐈₁|k̃⟩(j|j) + 𝐈₁|k̃⟩(l|l) + ĥ|k̃⟩ + 𝐈₁|k̃⟩(- G(i,j)) + 𝐈₁|k̃⟩F(i,j) + 𝐈₁|k̃⟩(- G(i,l)) + 𝐈₁|k̃⟩F(i,l) + 𝐈₁|k̃⟩(- G(j,l)) + 𝐈₁|k̃⟩F(j,l) + -[i|k̃]|i⟩ + [i|i]|k̃⟩ + -[j|k̃]|j⟩ + [j|j]|k̃⟩ + -[l|k̃]|l⟩ + [l|l]|k̃⟩
  [1, 2]  =  𝐈₁|l̃⟩(l|k) + 𝐈₁|l̃⟩(- [i l|k i]) + 𝐈₁|l̃⟩[i l|i k] + 𝐈₁|l̃⟩(- [j l|k j]) + 𝐈₁|l̃⟩[j l|j k] + -[l|l̃]|k⟩ + [l|k]|l̃⟩
, OrbitalEquation(l̃):
  [2, 1]  =  𝐈₁|k̃⟩(k|l) + 𝐈₁|k̃⟩(- [i k|l i]) + 𝐈₁|k̃⟩[i k|i l] + 𝐈₁|k̃⟩(- [j k|l j]) + 𝐈₁|k̃⟩[j k|j l] + -[k|k̃]|l⟩ + [k|l]|k̃⟩
  [2, 2]  =  𝐈₁|l̃⟩(i|i) + 𝐈₁|l̃⟩(j|j) + 𝐈₁|l̃⟩(k|k) + ĥ|l̃⟩ + 𝐈₁|l̃⟩(- G(i,j)) + 𝐈₁|l̃⟩F(i,j) + 𝐈₁|l̃⟩(- G(i,k)) + 𝐈₁|l̃⟩F(i,k) + 𝐈₁|l̃⟩(- G(j,k)) + 𝐈₁|l̃⟩F(j,k) + -[i|l̃]|i⟩ + [i|i]|l̃⟩ + -[j|l̃]|j⟩ + [j|j]|l̃⟩ + -[k|l̃]|k⟩ + [k|k]|l̃⟩
], Any[(i|i), 𝐈₁, (j|j), (l|l), ĥ, G(i,j), F(i,j), G(i,l), F(i,l), G(j,l)  …  [j k|l j], [j k|j l], [k|k̃], [k|l], (k|k), G(i,k), F(i,k), G(j,k), F(j,k), [k|k]])</code></pre><p>We can investigate the <a href="#EnergyExpressions.MCEquationSystem"><code>MCEquationSystem</code></a> object <code>eqs</code> a bit. It consists of two coupled equations:</p><pre><code class="language-julia-repl">julia&gt; eqs.equations
2-element Array{EnergyExpressions.OrbitalEquation{Symbol,SparseArrays.SparseMatrixCSC{LinearCombinationEquation,Int64}},1}:
 OrbitalEquation(k̃):
  [1, 1]  =  𝐈₁|k̃⟩(i|i) + 𝐈₁|k̃⟩(j|j) + 𝐈₁|k̃⟩(l|l) + ĥ|k̃⟩ + 𝐈₁|k̃⟩(- G(i,j)) + 𝐈₁|k̃⟩F(i,j) + 𝐈₁|k̃⟩(- G(i,l)) + 𝐈₁|k̃⟩F(i,l) + 𝐈₁|k̃⟩(- G(j,l)) + 𝐈₁|k̃⟩F(j,l) + -[i|k̃]|i⟩ + [i|i]|k̃⟩ + -[j|k̃]|j⟩ + [j|j]|k̃⟩ + -[l|k̃]|l⟩ + [l|l]|k̃⟩
  [1, 2]  =  𝐈₁|l̃⟩(l|k) + 𝐈₁|l̃⟩(- [i l|k i]) + 𝐈₁|l̃⟩[i l|i k] + 𝐈₁|l̃⟩(- [j l|k j]) + 𝐈₁|l̃⟩[j l|j k] + -[l|l̃]|k⟩ + [l|k]|l̃⟩

 OrbitalEquation(l̃):
  [2, 1]  =  𝐈₁|k̃⟩(k|l) + 𝐈₁|k̃⟩(- [i k|l i]) + 𝐈₁|k̃⟩[i k|i l] + 𝐈₁|k̃⟩(- [j k|l j]) + 𝐈₁|k̃⟩[j k|j l] + -[k|k̃]|l⟩ + [k|l]|k̃⟩
  [2, 2]  =  𝐈₁|l̃⟩(i|i) + 𝐈₁|l̃⟩(j|j) + 𝐈₁|l̃⟩(k|k) + ĥ|l̃⟩ + 𝐈₁|l̃⟩(- G(i,j)) + 𝐈₁|l̃⟩F(i,j) + 𝐈₁|l̃⟩(- G(i,k)) + 𝐈₁|l̃⟩F(i,k) + 𝐈₁|l̃⟩(- G(j,k)) + 𝐈₁|l̃⟩F(j,k) + -[i|l̃]|i⟩ + [i|i]|l̃⟩ + -[j|l̃]|j⟩ + [j|j]|l̃⟩ + -[k|l̃]|k⟩ + [k|k]|l̃⟩</code></pre><p>The first equation consists of the following terms:</p><pre><code class="language-julia-repl">julia&gt; eqs.equations[1].one_body
0-element Array{EnergyExpressions.MCCoeff,1}

julia&gt; eqs.equations[1].direct_terms
3-element Array{Pair{Int64,Array{EnergyExpressions.MCCoeff,1}},1}:
 13 =&gt; [MCCoeff{Int64}(1, 1, 1, Int64[])]
 14 =&gt; [MCCoeff{Int64}(1, 1, 1, Int64[])]
 12 =&gt; [MCCoeff{Int64}(1, 1, 1, Int64[])]

julia&gt; eqs.equations[1].exchange_terms
3-element Array{Tuple{Any,EnergyExpressions.MCCoeff,Any},1}:
 ([i|k̃], EnergyExpressions.MCCoeff{Int64}(1, 1, -1, Int64[]), :i)
 ([j|k̃], EnergyExpressions.MCCoeff{Int64}(1, 1, -1, Int64[]), :j)
 ([l|k̃], EnergyExpressions.MCCoeff{Int64}(1, 1, -1, Int64[]), :l)

julia&gt; eqs.equations[1].source_terms
4-element Array{Pair{Int64,Array{Tuple{EnergyExpressions.MCCoeff,Any},1}},1}:
  2 =&gt; [(MCCoeff{Int64}(1, 1, 1, [1]), :k̃), (MCCoeff{Int64}(1, 1, 1, [3]), :k̃), (MCCoeff{Int64}(1, 1, 1, [4]), :k̃), (MCCoeff{Int64}(1, 1, -1, [6]), :k̃), (MCCoeff{Int64}(1, 1, 1, [7]), :k̃), (MCCoeff{Int64}(1, 1, -1, [8]), :k̃), (MCCoeff{Int64}(1, 1, 1, [9]), :k̃), (MCCoeff{Int64}(1, 1, -1, [10]), :k̃), (MCCoeff{Int64}(1, 1, 1, [11]), :k̃), (MCCoeff{Int64}(1, 2, 1, [15]), :l̃), (MCCoeff{Int64}(1, 2, -1, [16]), :l̃), (MCCoeff{Int64}(1, 2, 1, [17]), :l̃), (MCCoeff{Int64}(1, 2, -1, [18]), :l̃), (MCCoeff{Int64}(1, 2, 1, [19]), :l̃)]
  5 =&gt; [(MCCoeff{Int64}(1, 1, 1, Int64[]), :k̃)]
 21 =&gt; [(MCCoeff{Int64}(1, 2, 1, Int64[]), :l̃)]
 20 =&gt; [(MCCoeff{Int64}(1, 2, -1, Int64[]), :k)]</code></pre><p>where the <a href="#EnergyExpressions.MCCoeff"><code>MCCoeff</code></a> objects indicate which components of the mixing coefficient vector <span>$\vec{c}$</span> need to be multiplied, and all the integers are pointers to the list of common integrals:</p><pre><code class="language-julia-repl">julia&gt; eqs.integrals
34-element Array{Any,1}:
 (i|i)
 𝐈₁
 (j|j)
 (l|l)
 ĥ
 G(i,j)
 F(i,j)
 G(i,l)
 F(i,l)
 G(j,l)
 F(j,l)
 [i|i]
 [j|j]
 [l|l]
 (l|k)
 [i l|k i]
 [i l|i k]
 [j l|k j]
 [j l|j k]
 [l|l̃]
 [l|k]
 (k|l)
 [i k|l i]
 [i k|i l]
 [j k|l j]
 [j k|j l]
 [k|k̃]
 [k|l]
 (k|k)
 G(i,k)
 F(i,k)
 G(j,k)
 F(j,k)
 [k|k]</code></pre><p>From this we see that the <code>𝐈₁</code> (one-body identity operator) contribution to <code>|k̃⟩</code> can be written as a linear combination of <code>|k̃⟩</code> and <code>|l̃⟩</code>, weighted by different components of the mixing coefficient vector <span>$\vec{c}$</span> and various other integrals. This is all the information necessary to set up an efficient equation solver.</p><h2><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.MCCoeff" href="#EnergyExpressions.MCCoeff"><code>EnergyExpressions.MCCoeff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MCCoeff(i, j, coeff, integrals=[])</code></pre><p>Represents the coefficient of one term in the multi-configurational expansion. <code>i</code> and <code>j</code> are indices in the mixing-coefficient vector c (which is subject to optimization, and thus has to be referred to), <code>coeff</code> is an additional coefficient, and <code>integrals</code> is a list of indices into the vector of common integrals, the values of which should be multiplied to form the overall coefficient.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/7c522142f3f36916ea213d0f8d91760ca6d26c6d/src/multi_configurational_equations.jl#L1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.OrbitalEquation" href="#EnergyExpressions.OrbitalEquation"><code>EnergyExpressions.OrbitalEquation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">OrbitalEquation(orbital, equation,
                one_body, direct_terms, exchange_terms, source_terms)</code></pre><p>Represents the integro-differential equation for <code>orbital</code>, expressed as a linear combination of the different terms, with pointers to the list of common integrals that is stored by the encompassing <a href="#EnergyExpressions.MCEquationSystem"><code>MCEquationSystem</code></a> object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/7c522142f3f36916ea213d0f8d91760ca6d26c6d/src/multi_configurational_equations.jl#L18-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.MCEquationSystem" href="#EnergyExpressions.MCEquationSystem"><code>EnergyExpressions.MCEquationSystem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MCEquationSystem(equations, integrals)</code></pre><p>Represents a coupled system of integro-differential <code>equations</code>, resulting from the variation of a multi-configurational <a href="@ref"><code>EnergyExpression</code></a>, with respect to all constituent orbitals. All <code>integrals</code> that are in common between the <code>equations</code> need only be computed once per iteration, for efficiency.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/7c522142f3f36916ea213d0f8d91760ca6d26c6d/src/multi_configurational_equations.jl#L42-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.pushifmissing!" href="#EnergyExpressions.pushifmissing!"><code>EnergyExpressions.pushifmissing!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pushifmissing!(vector, element)</code></pre><p>Push <code>element</code> to the end of <code>vector</code>, if not already present. Returns the index of <code>element</code> in <code>vector</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/7c522142f3f36916ea213d0f8d91760ca6d26c6d/src/multi_configurational_equations.jl#L56-L61">source</a></section><footer><hr/><a class="previous" href="../variations/"><span class="direction">Previous</span><span class="title">Variation</span></a></footer></article></body></html>
