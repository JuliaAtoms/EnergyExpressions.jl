<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>N-body matrix elements · EnergyExpressions</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script src="../assets/latex.js"></script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.svg" alt="EnergyExpressions logo"/></a><h1>EnergyExpressions</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Theory</span><ul><li><a class="toctext" href="../notation/">Notation</a></li><li><a class="toctext" href="../energy_expressions/">Energy Expressions</a></li><li><a class="toctext" href="../calculus_of_variations/">Calculus of Variations</a></li></ul></li><li><span class="toctext">Implementation</span><ul><li><a class="toctext" href="../conjugate_orbitals/">Conjugate orbitals</a></li><li><a class="toctext" href="../slater_determinants/">Slater determinants</a></li><li><a class="toctext" href="../nbody_operators/">N-body operators</a></li><li class="current"><a class="toctext" href>N-body matrix elements</a><ul class="internal"><li><a class="toctext" href="#Calculation-of-determinants-1">Calculation of determinants</a></li></ul></li><li><a class="toctext" href="../common_operators/">Common N-body operators</a></li><li><a class="toctext" href="../equations/">N-body equations</a></li><li><a class="toctext" href="../variations/">Variation</a></li><li><a class="toctext" href="../system_of_equations/">System of equations</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Implementation</li><li><a href>N-body matrix elements</a></li></ul><a class="edit-page" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/master/docs/src/nbody_matrix_elements.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>N-body matrix elements</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="N-body-matrix-elements-1" href="#N-body-matrix-elements-1">N-body matrix elements</a></h1><p>The matrix element of an <span>$N$</span>-body operator between two Slater determinants may be expanded according to the Löwdin rules (which reduce to the Slater–Condon rules if all single-particle orbitals are orthogonal):</p><div>\[\begin{equation}
\label{eqn:matrix-element-expansion}
\matrixel{\Phi_A}{\Omega_n}{\Phi_B} =
\frac{1}{n!}\sum_p (-)^p
\matrixel{k_1k_2...k_n}{\Omega_n}{l_1l_2...l_n}
D^{AB}({k_1k_2...k_n}|{l_1l_2...l_n})
\end{equation}\]</div><p>where <span>$D^{AB}({k_1k_2...k_n}|{l_1l_2...l_n})$</span> is the determinant minor of the orbital overlap determinant <span>$D^{AB}$</span> with the rows <span>${k_1k_2...k_n}$</span> and columns <span>${l_1l_2...l_n}$</span> stricken out, and <span>$p$</span> runs over all permutations.</p><p>In general, a term in the expansion is thus of the form</p><div>\[\begin{equation}
\alpha\matrixel{k_1k_2...k_n}{\Omega_n}{l_1l_2...l_n}\braket{a}{b}\braket{c}{d}\dots\braket{y}{z},
\end{equation}\]</div><p>where <span>$\alpha$</span> is a scalar. This is represented by <a href="#EnergyExpressions.NBodyTerm"><code>NBodyTerm</code></a> type.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.NBodyTermFactor" href="#EnergyExpressions.NBodyTermFactor"><code>EnergyExpressions.NBodyTermFactor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NBodyTermFactor</code></pre><p>Abstract type for a factor in a term in a N-body matrix element expansion</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.OrbitalOverlap" href="#EnergyExpressions.OrbitalOverlap"><code>EnergyExpressions.OrbitalOverlap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OrbitalOverlap(a,b)</code></pre><p>Represents the overlap between the orbitals <code>a</code> and <code>b</code> in a N-body matrix element expansion.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; EnergyExpressions.OrbitalOverlap(:a,:b)
⟨a|b⟩</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L12-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.OrbitalMatrixElement" href="#EnergyExpressions.OrbitalMatrixElement"><code>EnergyExpressions.OrbitalMatrixElement</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OrbitalMatrixElement(a,o,b)</code></pre><p>Represents the N-body matrix element between the sets of orbitals <code>a</code> and <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; struct MyTwoBodyOperator &lt;: TwoBodyOperator end

julia&gt; EnergyExpressions.OrbitalMatrixElement((:a,:b), MyTwoBodyOperator(), (:c,:d))
⟨a b|MyTwoBodyOperator()|c d⟩</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L70-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.numbodies" href="#EnergyExpressions.numbodies"><code>EnergyExpressions.numbodies</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">numbodies(::NBodyOperator{N})</code></pre><p>Returns the number of bodies coupled by the N-body operator, i.e. <code>N</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_operators.jl#L12-L16">source</a><div><div><pre><code class="language-none">numbodies(lco::LinearCombinationOperator)</code></pre><p>Returns the maximum number of bodies coupled by any of the N-body operators in the <a href="../nbody_operators/#EnergyExpressions.LinearCombinationOperator"><code>LinearCombinationOperator</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_operators.jl#L70-L75">source</a><div><div><pre><code class="language-none">numbodies(::OrbitalOverlap)</code></pre><p>Returns the number of bodies coupled by the zero-body operator in the orbital overlap, i.e. <code>0</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L36-L41">source</a><div><div><pre><code class="language-none">numbodies(::OrbitalMatrixElement{N})</code></pre><p>Returns the number of bodies coupled by the operator, i.e. <code>N</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L92-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.NBodyTerm" href="#EnergyExpressions.NBodyTerm"><code>EnergyExpressions.NBodyTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NBodyTerm(factors, coeff)</code></pre><p>Structure representing one term in the expansion of a N-body matrix element.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L153-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.NBodyMatrixElement" href="#EnergyExpressions.NBodyMatrixElement"><code>EnergyExpressions.NBodyMatrixElement</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NBodyMatrixElement(terms)</code></pre><p>Structure representing the expansion of a N-body matrix element.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L247-L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.isdependent" href="#EnergyExpressions.isdependent"><code>EnergyExpressions.isdependent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isdependent(o::OrbitalOverlap, orbital)</code></pre><p>Returns <code>true</code> if the <a href="#EnergyExpressions.OrbitalOverlap"><code>OrbitalOverlap</code></a> <code>o</code> depends on <code>orbital</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isdependent(OrbitalOverlap(:a,:b), :a)
false

julia&gt; isdependent(OrbitalOverlap(:a,:b), Conjugate(:a))
true

julia&gt; isdependent(OrbitalOverlap(:a,:b), :b)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L44-L61">source</a><div><div><pre><code class="language-none">isdependent(o::OrbitalMatrixElement, orbital)</code></pre><p>Returns <code>true</code> if the <a href="#EnergyExpressions.OrbitalMatrixElement"><code>OrbitalMatrixElement</code></a> <code>o</code> depends on <code>orbital</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,), OneBodyHamiltonian(), (:b,)), :a)
false

julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,), OneBodyHamiltonian(), (:b,)), Conjugate(:a))
true

julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,), OneBodyHamiltonian(), (:b,)), :b)
true

julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,:b,), CoulombInteraction(), (:c,:d)), :c)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L119-L139">source</a><div><div><pre><code class="language-none">isdependent(nbt::NBodyTerm, o)</code></pre><p>Returns <code>true</code> if any of the factors comprising <code>nbt</code> is dependent on the orbital <code>o</code>. Not that the result is dependent on whether <code>o</code> is conjugated or not.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L199-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.transform" href="#EnergyExpressions.transform"><code>EnergyExpressions.transform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">transform(f::Function, nbt::NBodyTerm)</code></pre><p>Transform integrals of the the N-body matrix element expansion term <code>nbt</code> according to the function <code>f</code>, which should accept a single <a href="#EnergyExpressions.NBodyTermFactor"><code>NBodyTermFactor</code></a> as its argument.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L210-L216">source</a><div><div><pre><code class="language-none">transform(f::Function, nbme::NBodyMatrixElement)</code></pre><p>Transform integrals of the the N-body matrix element <code>nbme</code> according to the function <code>f</code>, which should accept a single <a href="#EnergyExpressions.NBodyTermFactor"><code>NBodyTermFactor</code></a> as its argument, and return a <a href="#EnergyExpressions.NBodyMatrixElement"><code>NBodyMatrixElement</code></a>. This is useful for adapting energy expressions to specific symmetries of the system under consideration.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L467-L475">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.overlap_matrix" href="#EnergyExpressions.overlap_matrix"><code>EnergyExpressions.overlap_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">overlap_matrix(a::SlaterDeterminant, b::SlaterDeterminant[, overlaps=[]])</code></pre><p>Generate the single-particle orbital overlap matrix, between the orbitals in the Slater determinants <code>a</code> and <code>b</code>. All orbitals are assumed to be orthogonal, except for those which are given in <code>overlaps</code>.</p><p><strong>Examples</strong></p><p>First we define two Slater determinants that have some orbitals in common:</p><pre><code class="language-julia-repl">julia&gt; sa = SlaterDeterminant([:i, :j, :l,:k̃])
i(1)j(2)l(3)k̃(4) - i(1)j(2)l(4)k̃(3) - i(1)j(3)l(2)k̃(4) + i(1)j(3)l(4)k̃(2) + …  + i(4)j(1)l(3)k̃(2) + i(4)j(2)l(1)k̃(3) - i(4)j(2)l(3)k̃(1) - i(4)j(3)l(1)k̃(2) + i(4)j(3)l(2)k̃(1)

julia&gt; sb = SlaterDeterminant([:i, :j, :k, :l̃])
i(1)j(2)k(3)l̃(4) - i(1)j(2)k(4)l̃(3) - i(1)j(3)k(2)l̃(4) + i(1)j(3)k(4)l̃(2) + …  + i(4)j(1)k(3)l̃(2) + i(4)j(2)k(1)l̃(3) - i(4)j(2)k(3)l̃(1) - i(4)j(3)k(1)l̃(2) + i(4)j(3)k(2)l̃(1)</code></pre><p>The orbital overlap matrix by default is</p><pre><code class="language-julia-repl">julia&gt; overlap_matrix(sa, sb)
4×4 SparseArrays.SparseMatrixCSC{EnergyExpressions.NBodyTerm,Int64} with 2 stored entries:
  [1, 1]  =  1
  [2, 2]  =  1</code></pre><p>which has only two non-zero entries, since only two of the orbitals are common between the Slater determinants <code>sa</code> and <code>sb</code>.</p><p>We can then define that the orbitals <code>k̃</code> and <code>l̃</code> are non-orthogonal:</p><pre><code class="language-julia-repl">julia&gt; overlap_matrix(sa, sb, [OrbitalOverlap(:k̃,:l̃)])
4×4 SparseArrays.SparseMatrixCSC{EnergyExpressions.NBodyTerm,Int64} with 3 stored entries:
  [1, 1]  =  1
  [2, 2]  =  1
  [4, 4]  =  ⟨k̃|l̃⟩</code></pre><p>We can even specify that the orbital <code>k̃</code> is non-orthogonal to <em>itself</em> (this can be useful when the <code>k̃</code> is a linear combination of orthogonal orbitals):</p><pre><code class="language-julia-repl">julia&gt; overlap_matrix(sa, sa, [OrbitalOverlap(:k̃,:k̃)])
4×4 SparseArrays.SparseMatrixCSC{EnergyExpressions.NBodyTerm,Int64} with 4 stored entries:
  [1, 1]  =  1
  [2, 2]  =  1
  [3, 3]  =  1
  [4, 4]  =  ⟨k̃|k̃⟩</code></pre><p>Notice that this overlap matrix was calculated between the Slater determinant <code>sa</code> and itself.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L496-L544">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.EnergyExpression" href="#EnergyExpressions.EnergyExpression"><code>EnergyExpressions.EnergyExpression</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">EnergyExpression</code></pre><p>An energy expression is given by an energy matrix, or interaction matrix, sandwiched between a vector of mixing coefficients: <code>E = c&#39;H*c</code>, where <code>c</code> are the mixing coefficients and <code>H</code> the energy matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L565-L572">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Matrix" href="#Base.Matrix"><code>Base.Matrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Matrix(op::QuantumOperator, slater_determinants[, overlaps])</code></pre><p>Generate the matrix corresponding to the quantum operator <code>op</code>, between the different <code>slater_determinants</code>. It is possible to specify non-orthogonalities between single-particle orbitals in <code>overlaps</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L575-L581">source</a></section><h2><a class="nav-anchor" id="Calculation-of-determinants-1" href="#Calculation-of-determinants-1">Calculation of determinants</a></h2><p>Actually computing the matrix element expansion <span>$\eqref{eqn:matrix-element-expansion}$</span> is a combinatorial problem, that grows factorially with the amount of non-orthogonal orbital pairs. Furthermore, of the <span>$(n!)^2$</span> terms generated from the expansion, only <span>$n!$</span> are distinct, due to the integrals being symmetric with respect to interchange of the coordinates [hence the normalization factor <span>$(n!)^{-1}$</span>]. Thankfully, there are few symmetries that can be employed, to generate only the distinct permutations, as well as the fact that the overlap matrix is very sparse.</p><h3><a class="nav-anchor" id="Finding-non-zero-minors-of-the-overlap-determinant-1" href="#Finding-non-zero-minors-of-the-overlap-determinant-1">Finding non-zero minors of the overlap determinant</a></h3><p>The algorithm to find which minor determinants <span>$\Gamma^{(N)}(k_1k_2...k_N|l_1l_2...l_N)$</span> do not vanish, and hence which <span>$N$</span> orbitals <span>$k_1k_2...k_N,l_1l_2...l_N$</span> the <span>$N$</span>-body operator should be contracted over, is described briefly below. It is devised to be optimal for orthogonal orbitals (i.e. linear complexity <span>$\mathcal{O}(Nn)$</span> where <span>$n$</span> is the number of orbitals), and near-optimal for a small amount of non-orthogonal orbitals.</p><p>Given:</p><ul><li>An <span>$N$</span>-body operator (implying <span>$N$</span> rows and <span>$N$</span> need to stricken out), and</li><li>an <span>$n\times n$</span> matrix, with coordinates of non-zero matrix elements: <span>$I,J$</span> (from these vectors, vanishing rows/columns can easily be deduced <span>$\implies$</span> <span>$N_r$</span> row/<span>$N_c$</span> column &quot;rank&quot;, i.e. yet to be stricken out),</li></ul><p>do</p><ul><li>find all <span>$N_r$</span>-combinations of the remaining rows,</li><li>for each such combination, find all columns which would be affected if striking out that particular combination of rows,<ul><li>if the &quot;support&quot; (i.e. the only non-zero elements) of any of those columns vanishes when striking out the rows, that column must be stricken out, too. Total number of these columns is named <span>$N_{cm}$</span>,</li><li>if more than <span>$N_c$</span> columns must be stricken out (<span>$N_{cm}&gt;N_c$</span>), that row combination is unviable,</li><li>find all <span>$N_c - N_{cm}$</span>-combinations of the remaining columns,</li><li>for each such combination of columns, find all rows which would be affected,<ul><li>if the support of any of those rows vanishes when striking out the candidate columns, and the row is not in the candidate set of rows to be stricken out, the column combination is unviable.</li></ul></li></ul></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.nonzero_minors" href="#EnergyExpressions.nonzero_minors"><code>EnergyExpressions.nonzero_minors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nonzero_minors(N, overlap) -&gt; (ks,ls)</code></pre><p>Find all (distinct) minor determinants of order <code>N</code> of the orbital <code>overlap</code> matrix that do not vanish, i.e. all non-vanishing minors are guaranteed to be present, but not all of the returned minors are guaranteed to be non-zero. Vanishing minors returned arise when the overlap matrix is rank deficient, which is unlikely to happen when computing energy expressions, but must still be guarded against. This is most easily checked by actually calculating the <a href="#EnergyExpressions.cofactor"><code>cofactor</code></a>, which is most likely desired anyway.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/minors.jl#L3-L14">source</a></section><h3><a class="nav-anchor" id="Contracting-over-the-stricken-out-orbitals-1" href="#Contracting-over-the-stricken-out-orbitals-1">Contracting over the stricken out orbitals</a></h3><p>We use Julia&#39;s built-in <code>Base.Cartesian.@nloops</code> iterators to span the space of all possible choices of orbitals for the contraction of orbitals. If two or more orbitals are the same, the matrix element is trivially zero (the “Fermi hole”). To avoid double-counting, we also only consider those indices that are above the hyper-diagonal.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.detaxis" href="#EnergyExpressions.detaxis"><code>EnergyExpressions.detaxis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">detaxis(i::CartesianIndex{N})</code></pre><p>Generate the axis index vector for the determinant minor, whose rows or columns represented by the <code>CartesianIndex</code> <code>i</code> should be omitted. Implemented via <a href="../nbody_operators/#EnergyExpressions.complement"><code>complement</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L304-L310">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.detminor" href="#EnergyExpressions.detminor"><code>EnergyExpressions.detminor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">detminor(k, l, A)</code></pre><p>Calculate the <a href="https://en.wikipedia.org/wiki/Minor_(linear_algebra)">determinant minor</a> of <code>A</code>, where the rows <code>k</code> and the columns <code>l</code> have been stricken out.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L316-L322">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.cofactor" href="#EnergyExpressions.cofactor"><code>EnergyExpressions.cofactor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cofactor(k, l, A)</code></pre><p>Calculate the <a href="https://en.wikipedia.org/wiki/Minor_(linear_algebra)">cofactor</a> of <code>A</code>, where the rows <code>k</code> and the columns <code>l</code> have been stricken out. The cofactor is calculated recursively, by expanding the minor determinants in cofactors, so this function should only be used in case it is known that the cofactor is non-zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L341-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.det" href="#LinearAlgebra.det"><code>LinearAlgebra.det</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">det(A)</code></pre><p>Calculate the determinant of the matrix <code>A</code> whose elements are of the <a href="#EnergyExpressions.NBodyTerm"><code>NBodyTerm</code></a> type, by expanding the determinant along the first column. This is an expensive operation, and should only be done with relatively sparse matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L353-L360">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.permutation_sign" href="#EnergyExpressions.permutation_sign"><code>EnergyExpressions.permutation_sign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">permutation_sign(p)</code></pre><p>Calculate the sign of the permutation <code>p</code>, 1 if <code>iseven(p)</code>, -1 otherwise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L377-L382">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.powneg1" href="#EnergyExpressions.powneg1"><code>EnergyExpressions.powneg1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">powneg1(k) = (-)ᵏ</code></pre><p>Calculates powers of negative unity for integer <code>k</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/nbody_matrix_elements.jl#L334-L338">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.@above_diagonal_loop" href="#EnergyExpressions.@above_diagonal_loop"><code>EnergyExpressions.@above_diagonal_loop</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">above_diagonal_loop(N, itersym, imax, args...)</code></pre><p>Generate <code>N</code> Cartesian loops for the iteration variables <code>itersym_{1:N}</code>, where <code>itersym_N ∈ 1:imax</code>, <code>itersym_{N-1} ∈ itersym_N+1:imax</code>, etc, i.e. above the hyper-diagonal of the <code>N</code>-dimensional hypercube with the side <code>imax</code>. <code>args...</code> is passed on to <code>Base.Cartesian._nloops</code>. <code>above_diagonal_loop</code> is nestable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @above_diagonal_loop 2 i 3 begin
           println(&quot;==================================&quot;)
           println(&quot;i = &quot;, Base.Cartesian.@ntuple 2 i)
           @above_diagonal_loop 2 j 3 begin
               println(&quot;j = &quot;, Base.Cartesian.@ntuple 2 j)
           end
       end
==================================
i = (2, 1)
j = (2, 1)
j = (3, 1)
j = (3, 2)
==================================
i = (3, 1)
j = (2, 1)
j = (3, 1)
j = (3, 2)
==================================
i = (3, 2)
j = (2, 1)
j = (3, 1)
j = (3, 2)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/loop_macros.jl#L1-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EnergyExpressions.@anti_diagonal_loop" href="#EnergyExpressions.@anti_diagonal_loop"><code>EnergyExpressions.@anti_diagonal_loop</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">anti_diagonal_loop(N, itersym, imax, args...)</code></pre><p>Generate <code>N</code> Cartesian loops for the iteration variables <code>itersym_{1:N}</code>, where <code>itersym_N ∈ 1:imax</code>, <code>itersym_{N-1} ∈ 1:imax\itersym_N</code>, etc, i.e. no two iteration variables have the same values simultaneously. <code>args...</code> is passed on to <code>Base.Cartesian._nloops</code>; however, <code>preexpr</code> is already used to skip the diagonal elements. <code>anti_diagonal_loop</code> is nestable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @anti_diagonal_loop 3 i 3 begin
           println(&quot;-----------------------------&quot;)
           t = (Base.Cartesian.@ntuple 3 i)
           println(&quot;$t: &quot;, allunique(t))
           @anti_diagonal_loop 2 j 2 begin
               u = (Base.Cartesian.@ntuple 2 j)
               println(&quot;$u: &quot;, allunique(u))
           end
       end
-----------------------------
(3, 2, 1): true
(2, 1): true
(1, 2): true
-----------------------------
(2, 3, 1): true
(2, 1): true
(1, 2): true
-----------------------------
(3, 1, 2): true
(2, 1): true
(1, 2): true
-----------------------------
(1, 3, 2): true
(2, 1): true
(1, 2): true
-----------------------------
(2, 1, 3): true
(2, 1): true
(1, 2): true
-----------------------------
(1, 2, 3): true
(2, 1): true
(1, 2): true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/aca9efdbc06a9aa9a32ae8de7fef64a3dc3179e9/src/loop_macros.jl#L43-L90">source</a></section><footer><hr/><a class="previous" href="../nbody_operators/"><span class="direction">Previous</span><span class="title">N-body operators</span></a><a class="next" href="../common_operators/"><span class="direction">Next</span><span class="title">Common N-body operators</span></a></footer></article></body></html>
