<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>N-body matrix elements · EnergyExpressions</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="EnergyExpressions logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="EnergyExpressions logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">EnergyExpressions</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../energy_expressions/">Energy Expressions</a></li><li><a class="tocitem" href="../calculus_of_variations/">Calculus of Variations</a></li></ul></li><li><span class="tocitem">Implementation</span><ul><li><a class="tocitem" href="../conjugate_orbitals/">Conjugate orbitals</a></li><li><a class="tocitem" href="../slater_determinants/">Slater determinants</a></li><li><a class="tocitem" href="../nbody_operators/">N-body operators</a></li><li class="is-active"><a class="tocitem" href>N-body matrix elements</a><ul class="internal"><li><a class="tocitem" href="#Calculation-of-determinants"><span>Calculation of determinants</span></a></li><li><a class="tocitem" href="#Occupation-number-representation"><span>Occupation number representation</span></a></li></ul></li><li><a class="tocitem" href="../common_operators/">Common N-body operators</a></li><li><a class="tocitem" href="../equations/">N-body equations</a></li><li><a class="tocitem" href="../variations/">Variation</a></li><li><a class="tocitem" href="../system_of_equations/">System of equations</a></li><li><a class="tocitem" href="../misc/">Miscellaneous</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Implementation</a></li><li class="is-active"><a href>N-body matrix elements</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>N-body matrix elements</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAtoms/EnergyExpressions.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/master/docs/src/nbody_matrix_elements.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="N-body-matrix-elements"><a class="docs-heading-anchor" href="#N-body-matrix-elements">N-body matrix elements</a><a id="N-body-matrix-elements-1"></a><a class="docs-heading-anchor-permalink" href="#N-body-matrix-elements" title="Permalink"></a></h1><p>The matrix element of an <span>$N$</span>-body operator between two Slater determinants may be expanded according to the Löwdin rules (which reduce to the Slater–Condon rules if all single-particle orbitals are orthogonal):</p><p class="math-container">\[\begin{equation}
\label{eqn:matrix-element-expansion}
\matrixel{\Phi_A}{\Omega_n}{\Phi_B} =
\frac{1}{n!}\sum_p (-)^p
\matrixel{k_1k_2...k_n}{\Omega_n}{l_1l_2...l_n}
D^{AB}({k_1k_2...k_n}|{l_1l_2...l_n})
\end{equation}\]</p><p>where <span>$D^{AB}({k_1k_2...k_n}|{l_1l_2...l_n})$</span> is the determinant minor of the orbital overlap determinant <span>$D^{AB}$</span> with the rows <span>${k_1k_2...k_n}$</span> and columns <span>${l_1l_2...l_n}$</span> stricken out, and <span>$p$</span> runs over all permutations.</p><p>In general, a term in the expansion is thus of the form</p><p class="math-container">\[\begin{equation}
\alpha\matrixel{k_1k_2...k_n}{\Omega_n}{l_1l_2...l_n}\braket{a}{b}\braket{c}{d}\dots\braket{y}{z},
\end{equation}\]</p><p>where <span>$\alpha$</span> is a scalar. This is represented by <a href="#EnergyExpressions.NBodyTerm"><code>NBodyTerm</code></a> type.</p><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.NBodyTermFactor" href="#EnergyExpressions.NBodyTermFactor"><code>EnergyExpressions.NBodyTermFactor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NBodyTermFactor</code></pre><p>Abstract type for a factor in a term in a N-body matrix element expansion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.OrbitalOverlap" href="#EnergyExpressions.OrbitalOverlap"><code>EnergyExpressions.OrbitalOverlap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrbitalOverlap(a,b)</code></pre><p>Represents the overlap between the orbitals <code>a</code> and <code>b</code> in a N-body matrix element expansion.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; EnergyExpressions.OrbitalOverlap(:a,:b)
⟨a|b⟩</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L12-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.OrbitalMatrixElement" href="#EnergyExpressions.OrbitalMatrixElement"><code>EnergyExpressions.OrbitalMatrixElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrbitalMatrixElement(a,o,b)</code></pre><p>Represents the N-body matrix element between the sets of orbitals <code>a</code> and <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct MyTwoBodyOperator &lt;: TwoBodyOperator end

julia&gt; EnergyExpressions.OrbitalMatrixElement((:a,:b), MyTwoBodyOperator(), (:c,:d))
⟨a b|MyTwoBodyOperator()|c d⟩</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L76-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.numbodies" href="#EnergyExpressions.numbodies"><code>EnergyExpressions.numbodies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numbodies(::NBodyOperator{N})</code></pre><p>Returns the number of bodies coupled by the N-body operator, i.e. <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_operators.jl#L21-L25">source</a></section><section><div><pre><code class="nohighlight hljs">numbodies(lco::LinearCombinationOperator)</code></pre><p>Returns the maximum number of bodies coupled by any of the N-body operators in the <a href="../nbody_operators/#EnergyExpressions.LinearCombinationOperator"><code>LinearCombinationOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_operators.jl#L92-L97">source</a></section><section><div><pre><code class="nohighlight hljs">numbodies(::OrbitalOverlap)</code></pre><p>Returns the number of bodies coupled by the zero-body operator in the orbital overlap, i.e. <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L42-L47">source</a></section><section><div><pre><code class="nohighlight hljs">numbodies(::OrbitalMatrixElement{N})</code></pre><p>Returns the number of bodies coupled by the operator, i.e. <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.NBodyTerm" href="#EnergyExpressions.NBodyTerm"><code>EnergyExpressions.NBodyTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NBodyTerm(factors, coeff)</code></pre><p>Structure representing one term in the expansion of a N-body matrix element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.NBodyMatrixElement" href="#EnergyExpressions.NBodyMatrixElement"><code>EnergyExpressions.NBodyMatrixElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NBodyMatrixElement(terms)</code></pre><p>Structure representing the expansion of a N-body matrix element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L288-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.NBodyMatrixElement-Union{Tuple{Cfg}, Tuple{Cfg, EnergyExpressions.LinearCombinationOperator, Cfg, Any}} where Cfg" href="#EnergyExpressions.NBodyMatrixElement-Union{Tuple{Cfg}, Tuple{Cfg, EnergyExpressions.LinearCombinationOperator, Cfg, Any}} where Cfg"><code>EnergyExpressions.NBodyMatrixElement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NBodyMatrixElement(a, op, b, overlap)</code></pre><p>Generate the matrix element of <code>op</code>, a linear combination of <a href="../nbody_operators/#EnergyExpressions.NBodyOperator"><code>NBodyOperator</code></a>, between the configurations (e.g. Slater determinants) <code>a</code> and <code>b</code>, according to the Löwdin rules. The matrix <code>overlap</code> contains the mutual overlaps between all single-particle orbitals in the Slater determinants. If the orbitals are all orthogonal, the Löwdin rules collapse to the Slater–Condon rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L644-L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.NBodyMatrixElement-Union{Tuple{N}, Tuple{Any, NBodyOperator{N}, Any, Any}} where N" href="#EnergyExpressions.NBodyMatrixElement-Union{Tuple{N}, Tuple{Any, NBodyOperator{N}, Any, Any}} where N"><code>EnergyExpressions.NBodyMatrixElement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NBodyMatrixElement(a, op, b, nzcofactors)</code></pre><p>Generate the matrix element of the N-body operator <code>op</code>, between the orbital sets <code>a</code> and <code>b</code>, where <code>nzcofactors</code> list all N-tuples for which the determinantal cofactor of the orbital overlap matrix is non-vanishing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L599-L606">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.NBodyMatrixElement-Union{Tuple{N}, Tuple{SlaterDeterminant, NBodyOperator{N}, SlaterDeterminant, AbstractMatrix{T} where T}} where N" href="#EnergyExpressions.NBodyMatrixElement-Union{Tuple{N}, Tuple{SlaterDeterminant, NBodyOperator{N}, SlaterDeterminant, AbstractMatrix{T} where T}} where N"><code>EnergyExpressions.NBodyMatrixElement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NBodyMatrixElement(a, op, b, overlap)</code></pre><p>Generate the matrix element of the N-body operator <code>op</code>, between the Slater determinants <code>a</code> and <code>b</code>, according to the Löwdin rules. The matrix <code>overlap</code> contains the mutual overlaps between all single-particle orbitals in the Slater determinants. If the orbitals are all orthogonal, the Löwdin rules collapse to the Slater–Condon rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L628-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.isdependent" href="#EnergyExpressions.isdependent"><code>EnergyExpressions.isdependent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isdependent(o::OrbitalOverlap, orbital)</code></pre><p>Returns <code>true</code> if the <a href="#EnergyExpressions.OrbitalOverlap"><code>OrbitalOverlap</code></a> <code>o</code> depends on <code>orbital</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isdependent(OrbitalOverlap(:a,:b), :a)
false

julia&gt; isdependent(OrbitalOverlap(:a,:b), Conjugate(:a))
true

julia&gt; isdependent(OrbitalOverlap(:a,:b), :b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L50-L67">source</a></section><section><div><pre><code class="nohighlight hljs">isdependent(o::OrbitalMatrixElement, orbital)</code></pre><p>Returns <code>true</code> if the <a href="#EnergyExpressions.OrbitalMatrixElement"><code>OrbitalMatrixElement</code></a> <code>o</code> depends on <code>orbital</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,), OneBodyHamiltonian(), (:b,)), :a)
false

julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,), OneBodyHamiltonian(), (:b,)), Conjugate(:a))
true

julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,), OneBodyHamiltonian(), (:b,)), :b)
true

julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,:b,), CoulombInteraction(), (:c,:d)), :c)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L138-L158">source</a></section><section><div><pre><code class="nohighlight hljs">isdependent(nbt::NBodyTerm, o)</code></pre><p>Returns <code>true</code> if any of the factors comprising <code>nbt</code> is dependent on the orbital <code>o</code>. Not that the result is dependent on whether <code>o</code> is conjugated or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L240-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.transform" href="#EnergyExpressions.transform"><code>EnergyExpressions.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform(f::Function, nbt::NBodyTerm)</code></pre><p>Transform integrals of the the N-body matrix element expansion term <code>nbt</code> according to the function <code>f</code>, which should accept a single <a href="#EnergyExpressions.NBodyTermFactor"><code>NBodyTermFactor</code></a> as its argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L251-L257">source</a></section><section><div><pre><code class="nohighlight hljs">transform(f::Function, nbme::NBodyMatrixElement)</code></pre><p>Transform integrals of the the N-body matrix element <code>nbme</code> according to the function <code>f</code>, which should accept a single <a href="#EnergyExpressions.NBodyTermFactor"><code>NBodyTermFactor</code></a> as its argument, and return a <a href="#EnergyExpressions.NBodyMatrixElement"><code>NBodyMatrixElement</code></a>. This is useful for adapting energy expressions to specific symmetries of the system under consideration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L664-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.overlap_matrix" href="#EnergyExpressions.overlap_matrix"><code>EnergyExpressions.overlap_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlap_matrix(a::Cfg, b::Cfg[, overlaps=[]]) where Cfg</code></pre><p>Generate the single-particle orbital overlap matrix, between the orbitals in the configurations (e.g. Slater determinants) <code>a</code> and <code>b</code>. All orbitals are assumed to be orthogonal, except for those which are given in <code>overlaps</code>.</p><p><strong>Examples</strong></p><p>First we define two Slater determinants that have some orbitals in common:</p><pre><code class="language-julia-repl hljs">julia&gt; sa = SlaterDeterminant([:i, :j, :l,:k̃])
i(1)j(2)l(3)k̃(4) - i(1)j(2)l(4)k̃(3) - i(1)j(3)l(2)k̃(4) + i(1)j(3)l(4)k̃(2) + …  + i(4)j(1)l(3)k̃(2) + i(4)j(2)l(1)k̃(3) - i(4)j(2)l(3)k̃(1) - i(4)j(3)l(1)k̃(2) + i(4)j(3)l(2)k̃(1)

julia&gt; sb = SlaterDeterminant([:i, :j, :k, :l̃])
i(1)j(2)k(3)l̃(4) - i(1)j(2)k(4)l̃(3) - i(1)j(3)k(2)l̃(4) + i(1)j(3)k(4)l̃(2) + …  + i(4)j(1)k(3)l̃(2) + i(4)j(2)k(1)l̃(3) - i(4)j(2)k(3)l̃(1) - i(4)j(3)k(1)l̃(2) + i(4)j(3)k(2)l̃(1)</code></pre><p>The orbital overlap matrix by default is</p><pre><code class="language-julia-repl hljs">julia&gt; overlap_matrix(sa, sb)
4×4 SparseArrays.SparseMatrixCSC{EnergyExpressions.NBodyTerm,Int64} with 2 stored entries:
  [1, 1]  =  1
  [2, 2]  =  1</code></pre><p>which has only two non-zero entries, since only two of the orbitals are common between the Slater determinants <code>sa</code> and <code>sb</code>.</p><p>We can then define that the orbitals <code>k̃</code> and <code>l̃</code> are non-orthogonal:</p><pre><code class="language-julia-repl hljs">julia&gt; overlap_matrix(sa, sb, [OrbitalOverlap(:k̃,:l̃)])
4×4 SparseArrays.SparseMatrixCSC{EnergyExpressions.NBodyTerm,Int64} with 3 stored entries:
  [1, 1]  =  1
  [2, 2]  =  1
  [4, 4]  =  ⟨k̃|l̃⟩</code></pre><p>We can even specify that the orbital <code>k̃</code> is non-orthogonal to <em>itself</em> (this can be useful when the <code>k̃</code> is a linear combination of orthogonal orbitals):</p><pre><code class="language-julia-repl hljs">julia&gt; overlap_matrix(sa, sa, [OrbitalOverlap(:k̃,:k̃)])
4×4 SparseArrays.SparseMatrixCSC{EnergyExpressions.NBodyTerm,Int64} with 4 stored entries:
  [1, 1]  =  1
  [2, 2]  =  1
  [3, 3]  =  1
  [4, 4]  =  ⟨k̃|k̃⟩</code></pre><p>Notice that this overlap matrix was calculated between the Slater determinant <code>sa</code> and itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L693-L741">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.compare" href="#EnergyExpressions.compare"><code>EnergyExpressions.compare</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare(a::NBodyMatrixElement, op, b::NBodyMatrixElement; kwargs...)</code></pre><p>Compare the <a href="#EnergyExpressions.NBodyMatrixElement"><code>NBodyMatrixElement</code></a>s <code>a</code> and <code>b</code> for similarity; all the terms of <code>a</code> need to be present in <code>b</code>, and vice versa, and their expansion coefficients have to agree when compared using <code>op</code>.</p><p>This function is mainly designed for testing purposes, i.e. to compare an expression with a reference, generated otherwise. It may not be performant. It may also fail on edge cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L380-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{EnergyExpressions.NBodyMatrixElement, EnergyExpressions.NBodyMatrixElement}" href="#Base.:==-Tuple{EnergyExpressions.NBodyMatrixElement, EnergyExpressions.NBodyMatrixElement}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:(==)(a::NBodyMatrixElement, b::NBodyMatrixElement; kwargs...)</code></pre><p>Test if <code>a</code> and <code>b</code> are exactly equal to each other, i.e. their terms all agree exactly, as well as the expansion coefficients. The actual comparison is performed by <a href="#EnergyExpressions.compare"><code>compare</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L410-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{EnergyExpressions.NBodyMatrixElement, EnergyExpressions.NBodyMatrixElement}" href="#Base.isapprox-Tuple{EnergyExpressions.NBodyMatrixElement, EnergyExpressions.NBodyMatrixElement}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.isapprox(a::NBodyMatrixElement, b::NBodyMatrixElement; kwargs...)</code></pre><p>Test if <code>a</code> and <code>b</code> are approximately equal to each other, i.e. their terms all agree exactly, and the expansion coefficients are approximately equal. The actual comparison is performed by <a href="#EnergyExpressions.compare"><code>compare</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L426-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.EnergyExpression" href="#EnergyExpressions.EnergyExpression"><code>EnergyExpressions.EnergyExpression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EnergyExpression</code></pre><p>An energy expression is given by an energy matrix, or interaction matrix, sandwiched between a vector of mixing coefficients: <code>E = c&#39;H*c</code>, where <code>c</code> are the mixing coefficients and <code>H</code> the energy matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L766-L773">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Matrix" href="#Base.Matrix"><code>Base.Matrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matrix(a, op::QuantumOperator, b[, overlaps])</code></pre><p>Generate the matrix corresponding to the quantum operator <code>op</code>, between the configurations (e.g. <a href="../slater_determinants/#EnergyExpressions.SlaterDeterminant"><code>SlaterDeterminant</code></a>s) <code>a</code> and <code>b</code>, i.e <code>⟨a|op|b⟩</code>. It is possible to specify non-orthogonalities between single-particle orbitals in <code>overlaps</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L776-L783">source</a></section><section><div><pre><code class="nohighlight hljs">Matrix(op::QuantumOperator, slater_determinants[, overlaps])</code></pre><p>Generate the matrix corresponding to the quantum operator <code>op</code>, between the different <code>slater_determinants</code>. It is possible to specify non-orthogonalities between single-particle orbitals in <code>overlaps</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L824-L830">source</a></section></article><h2 id="Calculation-of-determinants"><a class="docs-heading-anchor" href="#Calculation-of-determinants">Calculation of determinants</a><a id="Calculation-of-determinants-1"></a><a class="docs-heading-anchor-permalink" href="#Calculation-of-determinants" title="Permalink"></a></h2><p>Actually computing the matrix element expansion <span>$\eqref{eqn:matrix-element-expansion}$</span> is a combinatorial problem, that grows factorially with the amount of non-orthogonal orbital pairs. Furthermore, of the <span>$(n!)^2$</span> terms generated from the expansion, only <span>$n!$</span> are distinct, due to the integrals being symmetric with respect to interchange of the coordinates [hence the normalization factor <span>$(n!)^{-1}$</span>]. Thankfully, there are few symmetries that can be employed, to generate only the distinct permutations, as well as the fact that the overlap matrix is very sparse.</p><h3 id="Finding-non-zero-minors-of-the-overlap-determinant"><a class="docs-heading-anchor" href="#Finding-non-zero-minors-of-the-overlap-determinant">Finding non-zero minors of the overlap determinant</a><a id="Finding-non-zero-minors-of-the-overlap-determinant-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-non-zero-minors-of-the-overlap-determinant" title="Permalink"></a></h3><p>The algorithm to find which minor determinants <span>$\Gamma^{(N)}(k_1k_2...k_N|l_1l_2...l_N)$</span> do not vanish, and hence which <span>$N$</span> orbitals <span>$k_1k_2...k_N,l_1l_2...l_N$</span> the <span>$N$</span>-body operator should be contracted over, is described briefly below. It is devised to be optimal for orthogonal orbitals (i.e. linear complexity <span>$\mathcal{O}(Nn)$</span> where <span>$n$</span> is the number of orbitals), and near-optimal for a small amount of non-orthogonal orbitals.</p><p>Given:</p><ul><li>An <span>$N$</span>-body operator (implying <span>$N$</span> rows and <span>$N$</span> need to stricken out), and</li><li>an <span>$n\times n$</span> matrix, with coordinates of non-zero matrix elements: <span>$I,J$</span> (from these vectors, vanishing rows/columns can easily be deduced <span>$\implies$</span> <span>$N_r$</span> row/<span>$N_c$</span> column &quot;rank&quot;, i.e. yet to be stricken out),</li></ul><p>do</p><ul><li>find all <span>$N_r$</span>-combinations of the remaining rows,</li><li>for each such combination, find all columns which would be affected if striking out that particular combination of rows,<ul><li>if the &quot;support&quot; (i.e. the only non-zero elements) of any of those columns vanishes when striking out the rows, that column must be stricken out, too. Total number of these columns is named <span>$N_{cm}$</span>,</li><li>if more than <span>$N_c$</span> columns must be stricken out (<span>$N_{cm}&gt;N_c$</span>), that row combination is unviable,</li><li>find all <span>$N_c - N_{cm}$</span>-combinations of the remaining columns,</li><li>for each such combination of columns, find all rows which would be affected,<ul><li>if the support of any of those rows vanishes when striking out the candidate columns, and the row is not in the candidate set of rows to be stricken out, the column combination is unviable.</li></ul></li></ul></li></ul><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.nonzero_minors" href="#EnergyExpressions.nonzero_minors"><code>EnergyExpressions.nonzero_minors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonzero_minors(N, overlap) -&gt; (ks,ls)</code></pre><p>Find all (distinct) minor determinants of order <code>N</code> of the orbital <code>overlap</code> matrix that do not vanish, i.e. all non-vanishing minors are guaranteed to be present, but not all of the returned minors are guaranteed to be non-zero. Vanishing minors returned arise when the overlap matrix is rank deficient, which is unlikely to happen when computing energy expressions, but must still be guarded against. This is most easily checked by actually calculating the <a href="#EnergyExpressions.cofactor"><code>cofactor</code></a>, which is most likely desired anyway.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/minors.jl#L3-L14">source</a></section></article><h3 id="Contracting-over-the-stricken-out-orbitals"><a class="docs-heading-anchor" href="#Contracting-over-the-stricken-out-orbitals">Contracting over the stricken out orbitals</a><a id="Contracting-over-the-stricken-out-orbitals-1"></a><a class="docs-heading-anchor-permalink" href="#Contracting-over-the-stricken-out-orbitals" title="Permalink"></a></h3><p>We use Julia&#39;s built-in <code>Base.Cartesian.@nloops</code> iterators to span the space of all possible choices of orbitals for the contraction of orbitals. If two or more orbitals are the same, the matrix element is trivially zero (the “Fermi hole”). To avoid double-counting, we also only consider those indices that are above the hyper-diagonal.</p><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.detaxis" href="#EnergyExpressions.detaxis"><code>EnergyExpressions.detaxis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">detaxis(i::CartesianIndex{N})</code></pre><p>Generate the axis index vector for the determinant minor, whose rows or columns represented by the <code>CartesianIndex</code> <code>i</code> should be omitted. Implemented via <a href="../nbody_operators/#EnergyExpressions.complement"><code>complement</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L442-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.detminor" href="#EnergyExpressions.detminor"><code>EnergyExpressions.detminor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">detminor(k, l, A)</code></pre><p>Calculate the <a href="https://en.wikipedia.org/wiki/Minor_(linear_algebra)">determinant minor</a> of <code>A</code>, where the rows <code>k</code> and the columns <code>l</code> have been stricken out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L454-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.cofactor" href="#EnergyExpressions.cofactor"><code>EnergyExpressions.cofactor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cofactor(k, l, A)</code></pre><p>Calculate the <a href="https://en.wikipedia.org/wiki/Minor_(linear_algebra)">cofactor</a> of <code>A</code>, where the rows <code>k</code> and the columns <code>l</code> have been stricken out. The cofactor is calculated recursively, by expanding the minor determinants in cofactors, so this function should only be used in case it is known that the cofactor is non-zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L479-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.distinct_permutations" href="#EnergyExpressions.distinct_permutations"><code>EnergyExpressions.distinct_permutations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distinct_permutations(fun::Function, ::NBodyOperator{N}, b)</code></pre><p>Generate all distinct permutations <code>p</code> of <code>b</code> (which is expected to be of length <code>N</code>), and call <code>fun(σ, b[p])</code> where <code>σ=(-1)^p</code> is the sign of the permutation <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L581-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.det" href="#LinearAlgebra.det"><code>LinearAlgebra.det</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">det(A)</code></pre><p>Calculate the determinant of the matrix <code>A</code> whose elements are of the <a href="#EnergyExpressions.NBodyTerm"><code>NBodyTerm</code></a> type, by expanding the determinant along the first column. This is an expensive operation, and should only be done with relatively sparse matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L535-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.permutation_sign" href="#EnergyExpressions.permutation_sign"><code>EnergyExpressions.permutation_sign</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permutation_sign(p)</code></pre><p>Calculate the sign of the permutation <code>p</code>, 1 if <code>iseven(p)</code>, -1 otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L570-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.powneg1" href="#EnergyExpressions.powneg1"><code>EnergyExpressions.powneg1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">powneg1(k) = (-)ᵏ</code></pre><p>Calculates powers of negative unity for integer <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/nbody_matrix_elements.jl#L472-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.@above_diagonal_loop" href="#EnergyExpressions.@above_diagonal_loop"><code>EnergyExpressions.@above_diagonal_loop</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">above_diagonal_loop(N, itersym, imax, args...)</code></pre><p>Generate <code>N</code> Cartesian loops for the iteration variables <code>itersym_{1:N}</code>, where <code>itersym_N ∈ 1:imax</code>, <code>itersym_{N-1} ∈ itersym_N+1:imax</code>, etc, i.e. above the hyper-diagonal of the <code>N</code>-dimensional hypercube with the side <code>imax</code>. <code>args...</code> is passed on to <code>Base.Cartesian._nloops</code>. <code>above_diagonal_loop</code> is nestable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @above_diagonal_loop 2 i 3 begin
           println(&quot;==================================&quot;)
           println(&quot;i = &quot;, Base.Cartesian.@ntuple 2 i)
           @above_diagonal_loop 2 j 3 begin
               println(&quot;j = &quot;, Base.Cartesian.@ntuple 2 j)
           end
       end
==================================
i = (2, 1)
j = (2, 1)
j = (3, 1)
j = (3, 2)
==================================
i = (3, 1)
j = (2, 1)
j = (3, 1)
j = (3, 2)
==================================
i = (3, 2)
j = (2, 1)
j = (3, 1)
j = (3, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/loop_macros.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.@anti_diagonal_loop" href="#EnergyExpressions.@anti_diagonal_loop"><code>EnergyExpressions.@anti_diagonal_loop</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">anti_diagonal_loop(N, itersym, imax, args...)</code></pre><p>Generate <code>N</code> Cartesian loops for the iteration variables <code>itersym_{1:N}</code>, where <code>itersym_N ∈ 1:imax</code>, <code>itersym_{N-1} ∈ 1:imax\itersym_N</code>, etc, i.e. no two iteration variables have the same values simultaneously. <code>args...</code> is passed on to <code>Base.Cartesian._nloops</code>; however, <code>preexpr</code> is already used to skip the diagonal elements. <code>anti_diagonal_loop</code> is nestable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @anti_diagonal_loop 3 i 3 begin
           println(&quot;-----------------------------&quot;)
           t = (Base.Cartesian.@ntuple 3 i)
           println(&quot;$t: &quot;, allunique(t))
           @anti_diagonal_loop 2 j 2 begin
               u = (Base.Cartesian.@ntuple 2 j)
               println(&quot;$u: &quot;, allunique(u))
           end
       end
-----------------------------
(3, 2, 1): true
(2, 1): true
(1, 2): true
-----------------------------
(2, 3, 1): true
(2, 1): true
(1, 2): true
-----------------------------
(3, 1, 2): true
(2, 1): true
(1, 2): true
-----------------------------
(1, 3, 2): true
(2, 1): true
(1, 2): true
-----------------------------
(2, 1, 3): true
(2, 1): true
(1, 2): true
-----------------------------
(1, 2, 3): true
(2, 1): true
(1, 2): true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/loop_macros.jl#L43-L90">source</a></section></article><h2 id="Occupation-number-representation"><a class="docs-heading-anchor" href="#Occupation-number-representation">Occupation number representation</a><a id="Occupation-number-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Occupation-number-representation" title="Permalink"></a></h2><p>As an alternative to <a href="../slater_determinants/#EnergyExpressions.SlaterDeterminant"><code>SlaterDeterminant</code></a>, we also provide an implementation of the occupation number representation (i.e. second quantization). Every configuration is thus represented as a bit vector, indicating the occupation of a specific orbital by a <code>true</code> value. Excitations between two configurations are easily computed using bitwise operations. The present implementation is inspired by</p><ul><li>Scemama, A., &amp; Giner, E. (2013). An efficient implementation of Slater–Condon rules. CoRR, <a href="https://arxiv.org/abs/1311.6244">arXiv:1311.6244</a>,</li></ul><p>but extends upon it by also supporting non-orthogonal orbitals.</p><p>The benefit of this approach is much more efficient identification of which cofactors in <span>$\eqref{eqn:matrix-element-expansion}$</span> are non-zero, than the approach taken in <a href="#EnergyExpressions.nonzero_minors"><code>nonzero_minors</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.BitConfigurations" href="#EnergyExpressions.BitConfigurations"><code>EnergyExpressions.BitConfigurations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BitConfigurations(orbitals, configurations)</code></pre><p>Represent collection of <code>configurations</code> as bit vectors, where <code>true</code> values indicate that specific <code>orbitals</code> are occupied.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bcs = BitConfigurations([[:a,:b,:c], [:x,:b,:c], [:a,:y,:c], [:a,:b,:z]])
6-orbital 4-configuration BitConfigurations

1: a b c
2: a -&gt; x
3: b -&gt; y
4: c -&gt; z

julia&gt; h = FieldFreeOneBodyHamiltonian()
ĥ₀

julia&gt; Matrix(bcs, h)
4×4 SparseMatrixCSC{NBodyMatrixElement, Int64} with 10 stored entries:
 (a|a) + (b|b) + (c|c)  (a|x)                  - (b|y)                (c|z)
 (x|a)                  (b|b) + (c|c) + (x|x)  ⋅                      ⋅
 - (y|b)                ⋅                      (a|a) + (c|c) + (y|y)  ⋅
 (z|c)                  ⋅                      ⋅                      (a|a) + (b|b) + (z|z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/bit_configurations.jl#L192-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.Orbitals" href="#EnergyExpressions.Orbitals"><code>EnergyExpressions.Orbitals</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Orbitals(orbitals, overlaps, has_overlap, non_orthogonalities)</code></pre><p>Structure storing a common set of <code>orbitals</code>, along with possible <code>overlaps</code> between them, in case of non-orthogonalities. <code>has_overlap</code> is a boolean matrix indicates if a pair of orbitals have overlap, either due to non-orthogonality or if they are the same orbital. <code>non_orthogonalities</code> is a boolean vector that indicates if a specific orbital is non-orthogonal to <em>any</em> other orbital in the set of orbitals. This structure is used internally by <a href="#EnergyExpressions.BitConfigurations"><code>BitConfigurations</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/bit_configurations.jl#L29-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.non_zero_cofactors" href="#EnergyExpressions.non_zero_cofactors"><code>EnergyExpressions.non_zero_cofactors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">non_zero_cofactors(sd, N, i, j)</code></pre><p>Find all non-zero cofactors of the orbital overlap matrix between the Slater determinants <code>i</code> &amp; <code>j</code> of <code>sd</code>, generated when striking out <code>N</code> rows &amp; columns. This routine is tailored towards the case when few non-orthogonalities are present, e.g. approximately proportional to the number of orbitals.</p><p>Non-orthogonality between spin-orbitals is handled by dividing the them into two subspaces:</p><ol><li><p>The orthogonal spin-orbitals that are common to both Slater determinants (core orbitals),</p></li><li><p>All non-orthogonal orbitals, and the orbitals which differ between the Slater determinants (i.e. holes of <code>i</code> and particles of <code>j</code>).</p></li></ol><p>The relative phase between the Slater determinants is determined by group <code>2</code> alone, by permuting the particles to the positions of the holes, we find this phase. We can then formally permute them together to a diagonal block at lower-right corner of the orbital overlap matrix without incurring a phase change, since we need to permute the same number of rows and columns. We thus get this structure:</p><pre><code class="nohighlight hljs">                 ╷       ╷
                 │ 1 │   │
 det(Sᵢⱼ) = (-)ᵏ │───┼───│
                 │   │ 2 │
                 ╵       ╵</code></pre><p>where <code>k</code> is decided by the permutation necessary to put the particles in the positions of the holes.</p><p>Obviously, the determinant of the orbital matrix is now given by <code>det(Sᵢⱼ) = (-)ᵏ*det(2)</code>, since we trivially have <code>det(1)==1</code>.</p><p>Depending on the rank of <code>2</code> (determined by the number of hole–particle pairs and which spin-orbitals are non-orthogonal), we need to strike out at least <code>size(2,1)-rank(2)</code> rows/columns from <code>2</code>, and at most <code>min(N,size(2,1))</code>, i.e. for each value of <code>n ∈ size(2,1)-rank(2):min(N,size(2,1))</code>, we need to additionally strike out <code>m = N - n</code> rows from <code>1</code>, but since the determinant of subspace <code>1</code> is unity, regardless of how many rows/columns we&#39;ve stricken out, this is a trivial excercise. Of course, we also require that <code>m ≤ size(1,1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/2d2fa1a018bf115618990ed63e91fc23c030287f/src/bit_configurations.jl#L327-L373">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nbody_operators/">« N-body operators</a><a class="docs-footer-nextpage" href="../common_operators/">Common N-body operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Friday 14 October 2022 14:24">Friday 14 October 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
