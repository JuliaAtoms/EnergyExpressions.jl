<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>System of equations · EnergyExpressions</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="EnergyExpressions logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="EnergyExpressions logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">EnergyExpressions</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../energy_expressions/">Energy Expressions</a></li><li><a class="tocitem" href="../calculus_of_variations/">Calculus of Variations</a></li></ul></li><li><span class="tocitem">Implementation</span><ul><li><a class="tocitem" href="../conjugate_orbitals/">Conjugate orbitals</a></li><li><a class="tocitem" href="../slater_determinants/">Slater determinants</a></li><li><a class="tocitem" href="../nbody_operators/">N-body operators</a></li><li><a class="tocitem" href="../nbody_matrix_elements/">N-body matrix elements</a></li><li><a class="tocitem" href="../common_operators/">Common N-body operators</a></li><li><a class="tocitem" href="../equations/">N-body equations</a></li><li><a class="tocitem" href="../variations/">Variation</a></li><li class="is-active"><a class="tocitem" href>System of equations</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li></ul></li><li><a class="tocitem" href="../misc/">Miscellaneous</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Implementation</a></li><li class="is-active"><a href>System of equations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>System of equations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAtoms/EnergyExpressions.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/master/docs/src/system_of_equations.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="System-of-equations"><a class="docs-heading-anchor" href="#System-of-equations">System of equations</a><a id="System-of-equations-1"></a><a class="docs-heading-anchor-permalink" href="#System-of-equations" title="Permalink"></a></h1><p>When dealing with large energy expressions resulting from many configurations, when deriving the orbital equations (see <a href="../equations/#N-body-equations">N-body equations</a> and <a href="../variations/#Calculus-of-Variations-–-Implementation">Calculus of Variations – Implementation</a>), many of the integrals involved will be shared between the different terms of the equations. It is therefore of interest to gather a list of integrals that can be calculated once at every iteration (in a self-consistent procedure for finding eigenstates, or in time-propagation), and whose values can then be reused when solving the individual equations. The routines described below, although primitive, aid in this effort.</p><p>The idea is the following: With an energy expression on the form</p><p class="math-container">\[\begin{equation}
E(\vec{P},\vec{c}) = \frac{\vec{c}^H
\mat{H}\vec{c}}{\vec{c}^H\vec{c}}
\end{equation}\]</p><p>where <span>$\vec{P}$</span> is a set of orbitals, <span>$\vec{c}$</span> is a vector of mixing coefficients, and</p><p class="math-container">\[\begin{equation}
\mat{H}_{ij} \defd \matrixel{\chi_i}{\Hamiltonian}{\chi_j},
\end{equation}\]</p><p>all terms of the equations can be written on the form</p><p class="math-container">\[\begin{equation}
\label{eqn:equation-term}
\operator{A}\ket{\chi}
\underbrace{\left[
\sum_n \alpha_n \conj{c}_{i_n} c_{j_n}
\prod_k \int_{n_k}
\right]}_{\textrm{Rank 0}},
\end{equation}\]</p><p>(or on its dual form with conjugated orbitals) where <span>$\operator{A}$</span> is some one-body operator, <span>$\alpha_n$</span> a coefficient due to the energy expression, <span>$\conj{c}_{i_n} c_{j_n}$</span> the coefficient due to the multi-configurational expansion, and finally <span>$\int_{n_k}$</span> all the extra integrals (which are necessarily zero-body operators) that may appear due to non-orthogonal orbitals (and which may be shared between many equations). The operator <span>$\operator{A}$</span> can have ranks 0–2; formally, it can only have rank 0 (multiplication by a scalar) or 2 (multiplication by a matrix). What we somewhat sloppily to refer by “rank 1” is an operator of rank 2, but which is diagonal in the underlying coordinate, such as a local potential.</p><p>Thus, to efficiently perform an iteration, one would first compute all common integrals <span>$\int_k$</span>, and then for every equation term of the form <span>$\eqref{eqn:equation-term}$</span>, form the coefficient in the brakets, calculate the action of the operator <span>$\operator{A}$</span> on the orbital <span>$\chi$</span>, multiplied the coefficient.</p><p>There are a few important special cases of <span>$\eqref{eqn:equation-term}$</span>:</p><ol><li><p>Field-free, one-body Hamiltonian, i.e. <span>$\operator{A}=\hamiltonian_0$</span>. This is the contribution from the orbital <span>$\ket{\chi}$</span> to itself. Rank 2.</p></li><li><p>One-body Hamiltonian, including field, i.e. <span>$\operator{A}=\hamiltonian$</span>. This is the contribution from another orbital <span>$\ket{\chi&#39;}$</span> to <span>$\ket{\chi}$</span> via some off-diagonal coupling, such as an external field (e.g. an electro–magnetic field). Rank 2.</p></li><li><p>Direct interaction, i.e. <span>$\operator{A}=\direct{kl}$</span>, where two other orbitals <span>$\ket{\chi_k}$</span> and <span>$\ket{\chi_l}$</span> together form a potential acting on <span>$\ket{\chi}$</span>. “Rank 1”.</p></li><li><p>Exchange interaction, i.e. <span>$\operator{A}=\exchange{kl}$</span>, where another orbital <span>$\ket{\chi_k}$</span> and <span>$\ket{\chi}$</span> together form a potential acting on a third orbital <span>$\ket{\chi_l}$</span>. Rank 2.</p></li><li><p>Source term, i.e. a contribution that does not involve <span>$\ket{\chi}$</span> in any way. This term arises from other configurations in the multi-configurational expansion. Case 2. is also formulated in this way. Rank 0–2. If for some reason the source orbital and/or the operator acting on it is fixed, it may be possible to precompute the effect of the operator on the source orbital and reduce the computational complexity to a rank 0-equivalent operation.</p></li></ol><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>We start by defining a set of configurations and specifying that a few of the constituent orbitals are non-orthogonal:</p><pre><code class="language-julia-repl hljs">julia&gt; cfgs = [[:i, :j, :l, :k̃], [:i, :j, :k, :l̃]]
2-element Array{Array{Symbol,1},1}:
 [:i, :j, :l, :k̃]
 [:i, :j, :k, :l̃]

julia&gt; continua = [:k̃, :l̃]
2-element Array{Symbol,1}:
 :k̃
 :l̃

julia&gt; overlaps = [OrbitalOverlap(i,j) for i in continua for j in continua]
4-element Array{OrbitalOverlap{Symbol,Symbol},1}:
 ⟨k̃|k̃⟩
 ⟨k̃|l̃⟩
 ⟨l̃|k̃⟩
 ⟨l̃|l̃⟩</code></pre><p>We then set up the energy expression as before:</p><pre><code class="language-julia-repl hljs">julia&gt; H = OneBodyHamiltonian() + CoulombInteraction()
ĥ + ĝ

julia&gt; E = Matrix(H, SlaterDeterminant.(cfgs), overlaps)
2×2 Array{EnergyExpressions.NBodyMatrixElement,2}:
 (i|i)⟨k̃|k̃⟩ + (j|j)⟨k̃|k̃⟩ + (l|l)⟨k̃|k̃⟩ + (k̃|k̃) - G(i,j)⟨k̃|k̃⟩ + F(i,j)⟨k̃|k̃⟩ + … - G(i,k̃) + F(i,k̃) - G(j,k̃) + F(j,k̃) - G(l,k̃) + F(l,k̃)  …  (l|k)⟨k̃|l̃⟩ - [i l|k i]⟨k̃|l̃⟩ + [i l|i k]⟨k̃|l̃⟩ - [j l|k j]⟨k̃|l̃⟩ + [j l|j k]⟨k̃|l̃⟩ - [l k̃|l̃ k] + [l k̃|k l̃]
 (k|l)⟨l̃|k̃⟩ - [i k|l i]⟨l̃|k̃⟩ + [i k|i l]⟨l̃|k̃⟩ - [j k|l j]⟨l̃|k̃⟩ + [j k|j l]⟨l̃|k̃⟩ - [k l̃|k̃ l] + [k l̃|l k̃]                                     (i|i)⟨l̃|l̃⟩ + (j|j)⟨l̃|l̃⟩ + (k|k)⟨l̃|l̃⟩ + (l̃|l̃) - G(i,j)⟨l̃|l̃⟩ + F(i,j)⟨l̃|l̃⟩ + … - G(i,l̃) + F(i,l̃) - G(j,l̃) + F(j,l̃) - G(k,l̃) + F(k,l̃)</code></pre><p>Finally, we derive the coupled integro-differential equation system for the continuum orbitals <code>k̃</code>, <code>l̃</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; eqs = diff(E, Conjugate.(continua))
EnergyExpressions.MCEquationSystem(EnergyExpressions.OrbitalEquation{Symbol,SparseArrays.SparseMatrixCSC{LinearCombinationEquation,Int64}}[OrbitalEquation(k̃):
  [1, 1]  =  + (i|i)𝐈₁|k̃⟩ + (j|j)𝐈₁|k̃⟩ + (l|l)𝐈₁|k̃⟩ + ĥ|k̃⟩ - G(i,j)𝐈₁|k̃⟩ + F(i,j)𝐈₁|k̃⟩ - G(i,l)𝐈₁|k̃⟩ + F(i,l)𝐈₁|k̃⟩ - G(j,l)𝐈₁|k̃⟩ + F(j,l)𝐈₁|k̃⟩ - [i|k̃]|i⟩ + [i|i]|k̃⟩ - [j|k̃]|j⟩ + [j|j]|k̃⟩ - [l|k̃]|l⟩ + [l|l]|k̃⟩
  [1, 2]  =  + (l|k)𝐈₁|l̃⟩ - [i l|k i]𝐈₁|l̃⟩ + [i l|i k]𝐈₁|l̃⟩ - [j l|k j]𝐈₁|l̃⟩ + [j l|j k]𝐈₁|l̃⟩ - [l|l̃]|k⟩ + [l|k]|l̃⟩
, OrbitalEquation(l̃):
  [2, 1]  =  + (k|l)𝐈₁|k̃⟩ - [i k|l i]𝐈₁|k̃⟩ + [i k|i l]𝐈₁|k̃⟩ - [j k|l j]𝐈₁|k̃⟩ + [j k|j l]𝐈₁|k̃⟩ - [k|k̃]|l⟩ + [k|l]|k̃⟩
  [2, 2]  =  + (i|i)𝐈₁|l̃⟩ + (j|j)𝐈₁|l̃⟩ + (k|k)𝐈₁|l̃⟩ + ĥ|l̃⟩ - G(i,j)𝐈₁|l̃⟩ + F(i,j)𝐈₁|l̃⟩ - G(i,k)𝐈₁|l̃⟩ + F(i,k)𝐈₁|l̃⟩ - G(j,k)𝐈₁|l̃⟩ + F(j,k)𝐈₁|l̃⟩ - [i|l̃]|i⟩ + [i|i]|l̃⟩ - [j|l̃]|j⟩ + [j|j]|l̃⟩ - [k|l̃]|k⟩ + [k|k]|l̃⟩
], Any[(i|i), (j|j), (l|l), G(i,j), F(i,j), G(i,l), F(i,l), G(j,l), F(j,l), [i|i]  …  [j k|l j], [j k|j l], [k|k̃], [k|l], (k|k), G(i,k), F(i,k), G(j,k), F(j,k), [k|k]])</code></pre><p>We can investigate the <a href="#EnergyExpressions.MCEquationSystem"><code>MCEquationSystem</code></a> object <code>eqs</code> a bit. It consists of two coupled equations:</p><pre><code class="language-julia-repl hljs">julia&gt; eqs.equations
2-element Array{EnergyExpressions.OrbitalEquation{Symbol,SparseArrays.SparseMatrixCSC{LinearCombinationEquation,Int64}},1}:
 OrbitalEquation(k̃):
  [1, 1]  =  + (i|i)𝐈₁|k̃⟩ + (j|j)𝐈₁|k̃⟩ + (l|l)𝐈₁|k̃⟩ + ĥ|k̃⟩ - G(i,j)𝐈₁|k̃⟩ + F(i,j)𝐈₁|k̃⟩ - G(i,l)𝐈₁|k̃⟩ + F(i,l)𝐈₁|k̃⟩ - G(j,l)𝐈₁|k̃⟩ + F(j,l)𝐈₁|k̃⟩ - [i|k̃]|i⟩ + [i|i]|k̃⟩ - [j|k̃]|j⟩ + [j|j]|k̃⟩ - [l|k̃]|l⟩ + [l|l]|k̃⟩
  [1, 2]  =  + (l|k)𝐈₁|l̃⟩ - [i l|k i]𝐈₁|l̃⟩ + [i l|i k]𝐈₁|l̃⟩ - [j l|k j]𝐈₁|l̃⟩ + [j l|j k]𝐈₁|l̃⟩ - [l|l̃]|k⟩ + [l|k]|l̃⟩

 OrbitalEquation(l̃):
  [2, 1]  =  + (k|l)𝐈₁|k̃⟩ - [i k|l i]𝐈₁|k̃⟩ + [i k|i l]𝐈₁|k̃⟩ - [j k|l j]𝐈₁|k̃⟩ + [j k|j l]𝐈₁|k̃⟩ - [k|k̃]|l⟩ + [k|l]|k̃⟩
  [2, 2]  =  + (i|i)𝐈₁|l̃⟩ + (j|j)𝐈₁|l̃⟩ + (k|k)𝐈₁|l̃⟩ + ĥ|l̃⟩ - G(i,j)𝐈₁|l̃⟩ + F(i,j)𝐈₁|l̃⟩ - G(i,k)𝐈₁|l̃⟩ + F(i,k)𝐈₁|l̃⟩ - G(j,k)𝐈₁|l̃⟩ + F(j,k)𝐈₁|l̃⟩ - [i|l̃]|i⟩ + [i|i]|l̃⟩ - [j|l̃]|j⟩ + [j|j]|l̃⟩ - [k|l̃]|k⟩ + [k|k]|l̃⟩</code></pre><p>The first equation consists of the following terms:</p><pre><code class="language-julia-repl hljs">julia&gt; eqs.equations[1].terms
6-element Array{Pair{Int64,Array{EnergyExpressions.MCTerm,1}},1}:
  0 =&gt; [MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, 𝐈₁, :k̃, [1]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, 𝐈₁, :k̃, [2]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, 𝐈₁, :k̃, [3]), MCTerm{Int64,OneBodyHamiltonian,Symbol}(1, 1, 1, ĥ, :k̃, Int64[]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, -1, 𝐈₁, :k̃, [4]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, 𝐈₁, :k̃, [5]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, -1, 𝐈₁, :k̃, [6]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, 𝐈₁, :k̃, [7]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, -1, 𝐈₁, :k̃, [8]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 1, 1, 𝐈₁, :k̃, [9]), MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, -1, [i|k̃], :i, Int64[]), MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, -1, [j|k̃], :j, Int64[]), MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, -1, [l|k̃], :l, Int64[]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 2, 1, 𝐈₁, :l̃, [13]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 2, -1, 𝐈₁, :l̃, [14]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 2, 1, 𝐈₁, :l̃, [15]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 2, -1, 𝐈₁, :l̃, [16]), MCTerm{Int64,IdentityOperator{1},Symbol}(1, 2, 1, 𝐈₁, :l̃, [17])]
 10 =&gt; [MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, 1, [i|i], :k̃, Int64[])]
 19 =&gt; [MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 2, 1, [l|k], :l̃, Int64[])]
 11 =&gt; [MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, 1, [j|j], :k̃, Int64[])]
 12 =&gt; [MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 1, 1, [l|l], :k̃, Int64[])]
 18 =&gt; [MCTerm{Int64,ContractedOperator{1,2,1,Symbol,CoulombInteraction,Symbol},Symbol}(1, 2, -1, [l|l̃], :k, Int64[])]</code></pre><p>where the <a href="#EnergyExpressions.MCTerm"><code>MCTerm</code></a> objects indicate which components of the mixing coefficient vector <span>$\vec{c}$</span> need to be multiplied, and all the integers are pointers to the list of common integrals:</p><pre><code class="language-julia-repl hljs">julia&gt; eqs.integrals
32-element Array{Any,1}:
 (i|i)
 (j|j)
 (l|l)
 G(i,j)
 F(i,j)
 G(i,l)
 F(i,l)
 G(j,l)
 F(j,l)
 [i|i]
 [j|j]
 [l|l]
 (l|k)
 [i l|k i]
 [i l|i k]
 [j l|k j]
 [j l|j k]
 [l|l̃]
 [l|k]
 (k|l)
 [i k|l i]
 [i k|i l]
 [j k|l j]
 [j k|j l]
 [k|k̃]
 [k|l]
 (k|k)
 G(i,k)
 F(i,k)
 G(j,k)
 F(j,k)
 [k|k]</code></pre><p>From this we see that the <code>𝐈₁</code> (one-body identity operator) contribution to <code>|k̃⟩</code> can be written as a linear combination of <code>|k̃⟩</code> and <code>|l̃⟩</code>, weighted by different components of the mixing coefficient vector <span>$\vec{c}$</span> and various other integrals. This is all the information necessary to set up an efficient equation solver.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.MCTerm" href="#EnergyExpressions.MCTerm"><code>EnergyExpressions.MCTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MCTerm(i, j, coeff, operator, source_orbital, integrals=[])</code></pre><p>Represents one term in the multi-configurational expansion. <code>i</code> and <code>j</code> are indices in the mixing-coefficient vector c (which is subject to optimization, and thus has to be referred to), <code>coeff</code> is an additional coefficient, and <code>integrals</code> is a list of indices into the vector of common integrals, the values of which should be multiplied to form the overall coefficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/9887575e60f22103264dbf85168ee210fb61912b/src/multi_configurational_equations.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.OrbitalEquation" href="#EnergyExpressions.OrbitalEquation"><code>EnergyExpressions.OrbitalEquation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrbitalEquation(orbital, equation,
                one_body, direct_terms, exchange_terms, source_terms)</code></pre><p>Represents the integro-differential equation for <code>orbital</code>, expressed as a linear combination of the different terms, with pointers to the list of common integrals that is stored by the encompassing <a href="#EnergyExpressions.MCEquationSystem"><code>MCEquationSystem</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/9887575e60f22103264dbf85168ee210fb61912b/src/multi_configurational_equations.jl#L26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.orbital_equation" href="#EnergyExpressions.orbital_equation"><code>EnergyExpressions.orbital_equation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orbital_equation(E::EnergyExpression, orbital, integrals::Vector)</code></pre><p>Generate the <a href="#EnergyExpressions.OrbitalEquation"><code>OrbitalEquation</code></a> governing <code>orbital</code> by varying the <a href="../nbody_matrix_elements/#EnergyExpressions.EnergyExpression"><code>EnergyExpression</code></a> <code>E</code>, and storing common expressions in <code>integrals</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/9887575e60f22103264dbf85168ee210fb61912b/src/multi_configurational_equations.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.MCEquationSystem" href="#EnergyExpressions.MCEquationSystem"><code>EnergyExpressions.MCEquationSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MCEquationSystem(equations, integrals)</code></pre><p>Represents a coupled system of integro-differential <code>equations</code>, resulting from the variation of a multi-configurational <a href="../nbody_matrix_elements/#EnergyExpressions.EnergyExpression"><code>EnergyExpression</code></a>, with respect to all constituent orbitals. All <code>integrals</code> that are in common between the <code>equations</code> need only be computed once per iteration, for efficiency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/9887575e60f22103264dbf85168ee210fb61912b/src/multi_configurational_equations.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.pushifmissing!" href="#EnergyExpressions.pushifmissing!"><code>EnergyExpressions.pushifmissing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pushifmissing!(vector, element)</code></pre><p>Push <code>element</code> to the end of <code>vector</code>, if not already present. Returns the index of <code>element</code> in <code>vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/9887575e60f22103264dbf85168ee210fb61912b/src/multi_configurational_equations.jl#L67-L72">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variations/">« Variation</a><a class="docs-footer-nextpage" href="../misc/">Miscellaneous »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Saturday 15 October 2022 07:45">Saturday 15 October 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
