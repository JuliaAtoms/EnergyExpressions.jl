<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>N-body matrix elements · EnergyExpressions</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="EnergyExpressions logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="EnergyExpressions logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">EnergyExpressions</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../energy_expressions/">Energy Expressions</a></li><li><a class="tocitem" href="../calculus_of_variations/">Calculus of Variations</a></li></ul></li><li><span class="tocitem">Implementation</span><ul><li><a class="tocitem" href="../conjugate_orbitals/">Conjugate orbitals</a></li><li><a class="tocitem" href="../slater_determinants/">Slater determinants</a></li><li><a class="tocitem" href="../nbody_operators/">N-body operators</a></li><li class="is-active"><a class="tocitem" href>N-body matrix elements</a><ul class="internal"><li><a class="tocitem" href="#Calculation-of-determinants"><span>Calculation of determinants</span></a></li></ul></li><li><a class="tocitem" href="../common_operators/">Common N-body operators</a></li><li><a class="tocitem" href="../equations/">N-body equations</a></li><li><a class="tocitem" href="../variations/">Variation</a></li><li><a class="tocitem" href="../system_of_equations/">System of equations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Implementation</a></li><li class="is-active"><a href>N-body matrix elements</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>N-body matrix elements</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAtoms/EnergyExpressions.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/master/docs/src/nbody_matrix_elements.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="N-body-matrix-elements"><a class="docs-heading-anchor" href="#N-body-matrix-elements">N-body matrix elements</a><a id="N-body-matrix-elements-1"></a><a class="docs-heading-anchor-permalink" href="#N-body-matrix-elements" title="Permalink"></a></h1><p>The matrix element of an <span>$N$</span>-body operator between two Slater determinants may be expanded according to the Löwdin rules (which reduce to the Slater–Condon rules if all single-particle orbitals are orthogonal):</p><p class="math-container">\[\begin{equation}
\label{eqn:matrix-element-expansion}
\matrixel{\Phi_A}{\Omega_n}{\Phi_B} =
\frac{1}{n!}\sum_p (-)^p
\matrixel{k_1k_2...k_n}{\Omega_n}{l_1l_2...l_n}
D^{AB}({k_1k_2...k_n}|{l_1l_2...l_n})
\end{equation}\]</p><p>where <span>$D^{AB}({k_1k_2...k_n}|{l_1l_2...l_n})$</span> is the determinant minor of the orbital overlap determinant <span>$D^{AB}$</span> with the rows <span>${k_1k_2...k_n}$</span> and columns <span>${l_1l_2...l_n}$</span> stricken out, and <span>$p$</span> runs over all permutations.</p><p>In general, a term in the expansion is thus of the form</p><p class="math-container">\[\begin{equation}
\alpha\matrixel{k_1k_2...k_n}{\Omega_n}{l_1l_2...l_n}\braket{a}{b}\braket{c}{d}\dots\braket{y}{z},
\end{equation}\]</p><p>where <span>$\alpha$</span> is a scalar. This is represented by <a href="#EnergyExpressions.NBodyTerm"><code>NBodyTerm</code></a> type.</p><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.NBodyTermFactor" href="#EnergyExpressions.NBodyTermFactor"><code>EnergyExpressions.NBodyTermFactor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NBodyTermFactor</code></pre><p>Abstract type for a factor in a term in a N-body matrix element expansion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.OrbitalOverlap" href="#EnergyExpressions.OrbitalOverlap"><code>EnergyExpressions.OrbitalOverlap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrbitalOverlap(a,b)</code></pre><p>Represents the overlap between the orbitals <code>a</code> and <code>b</code> in a N-body matrix element expansion.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; EnergyExpressions.OrbitalOverlap(:a,:b)
⟨a|b⟩</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L12-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.OrbitalMatrixElement" href="#EnergyExpressions.OrbitalMatrixElement"><code>EnergyExpressions.OrbitalMatrixElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrbitalMatrixElement(a,o,b)</code></pre><p>Represents the N-body matrix element between the sets of orbitals <code>a</code> and <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct MyTwoBodyOperator &lt;: TwoBodyOperator end

julia&gt; EnergyExpressions.OrbitalMatrixElement((:a,:b), MyTwoBodyOperator(), (:c,:d))
⟨a b|MyTwoBodyOperator()|c d⟩</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L76-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.numbodies" href="#EnergyExpressions.numbodies"><code>EnergyExpressions.numbodies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numbodies(::NBodyOperator{N})</code></pre><p>Returns the number of bodies coupled by the N-body operator, i.e. <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_operators.jl#L21-L25">source</a></section><section><div><pre><code class="nohighlight hljs">numbodies(lco::LinearCombinationOperator)</code></pre><p>Returns the maximum number of bodies coupled by any of the N-body operators in the <a href="../nbody_operators/#EnergyExpressions.LinearCombinationOperator"><code>LinearCombinationOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_operators.jl#L92-L97">source</a></section><section><div><pre><code class="nohighlight hljs">numbodies(::OrbitalOverlap)</code></pre><p>Returns the number of bodies coupled by the zero-body operator in the orbital overlap, i.e. <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L42-L47">source</a></section><section><div><pre><code class="nohighlight hljs">numbodies(::OrbitalMatrixElement{N})</code></pre><p>Returns the number of bodies coupled by the operator, i.e. <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.NBodyTerm" href="#EnergyExpressions.NBodyTerm"><code>EnergyExpressions.NBodyTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NBodyTerm(factors, coeff)</code></pre><p>Structure representing one term in the expansion of a N-body matrix element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.NBodyMatrixElement" href="#EnergyExpressions.NBodyMatrixElement"><code>EnergyExpressions.NBodyMatrixElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NBodyMatrixElement(terms)</code></pre><p>Structure representing the expansion of a N-body matrix element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.isdependent" href="#EnergyExpressions.isdependent"><code>EnergyExpressions.isdependent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isdependent(o::OrbitalOverlap, orbital)</code></pre><p>Returns <code>true</code> if the <a href="#EnergyExpressions.OrbitalOverlap"><code>OrbitalOverlap</code></a> <code>o</code> depends on <code>orbital</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isdependent(OrbitalOverlap(:a,:b), :a)
false

julia&gt; isdependent(OrbitalOverlap(:a,:b), Conjugate(:a))
true

julia&gt; isdependent(OrbitalOverlap(:a,:b), :b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L50-L67">source</a></section><section><div><pre><code class="nohighlight hljs">isdependent(o::OrbitalMatrixElement, orbital)</code></pre><p>Returns <code>true</code> if the <a href="#EnergyExpressions.OrbitalMatrixElement"><code>OrbitalMatrixElement</code></a> <code>o</code> depends on <code>orbital</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,), OneBodyHamiltonian(), (:b,)), :a)
false

julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,), OneBodyHamiltonian(), (:b,)), Conjugate(:a))
true

julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,), OneBodyHamiltonian(), (:b,)), :b)
true

julia&gt; isdependent(EnergyExpressions.OrbitalMatrixElement((:a,:b,), CoulombInteraction(), (:c,:d)), :c)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L131-L151">source</a></section><section><div><pre><code class="nohighlight hljs">isdependent(nbt::NBodyTerm, o)</code></pre><p>Returns <code>true</code> if any of the factors comprising <code>nbt</code> is dependent on the orbital <code>o</code>. Not that the result is dependent on whether <code>o</code> is conjugated or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L216-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.transform" href="#EnergyExpressions.transform"><code>EnergyExpressions.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform(f::Function, nbt::NBodyTerm)</code></pre><p>Transform integrals of the the N-body matrix element expansion term <code>nbt</code> according to the function <code>f</code>, which should accept a single <a href="#EnergyExpressions.NBodyTermFactor"><code>NBodyTermFactor</code></a> as its argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L227-L233">source</a></section><section><div><pre><code class="nohighlight hljs">transform(f::Function, nbme::NBodyMatrixElement)</code></pre><p>Transform integrals of the the N-body matrix element <code>nbme</code> according to the function <code>f</code>, which should accept a single <a href="#EnergyExpressions.NBodyTermFactor"><code>NBodyTermFactor</code></a> as its argument, and return a <a href="#EnergyExpressions.NBodyMatrixElement"><code>NBodyMatrixElement</code></a>. This is useful for adapting energy expressions to specific symmetries of the system under consideration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L605-L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.overlap_matrix" href="#EnergyExpressions.overlap_matrix"><code>EnergyExpressions.overlap_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlap_matrix(a::SlaterDeterminant, b::SlaterDeterminant[, overlaps=[]])</code></pre><p>Generate the single-particle orbital overlap matrix, between the orbitals in the Slater determinants <code>a</code> and <code>b</code>. All orbitals are assumed to be orthogonal, except for those which are given in <code>overlaps</code>.</p><p><strong>Examples</strong></p><p>First we define two Slater determinants that have some orbitals in common:</p><pre><code class="language-julia-repl hljs">julia&gt; sa = SlaterDeterminant([:i, :j, :l,:k̃])
i(1)j(2)l(3)k̃(4) - i(1)j(2)l(4)k̃(3) - i(1)j(3)l(2)k̃(4) + i(1)j(3)l(4)k̃(2) + …  + i(4)j(1)l(3)k̃(2) + i(4)j(2)l(1)k̃(3) - i(4)j(2)l(3)k̃(1) - i(4)j(3)l(1)k̃(2) + i(4)j(3)l(2)k̃(1)

julia&gt; sb = SlaterDeterminant([:i, :j, :k, :l̃])
i(1)j(2)k(3)l̃(4) - i(1)j(2)k(4)l̃(3) - i(1)j(3)k(2)l̃(4) + i(1)j(3)k(4)l̃(2) + …  + i(4)j(1)k(3)l̃(2) + i(4)j(2)k(1)l̃(3) - i(4)j(2)k(3)l̃(1) - i(4)j(3)k(1)l̃(2) + i(4)j(3)k(2)l̃(1)</code></pre><p>The orbital overlap matrix by default is</p><pre><code class="language-julia-repl hljs">julia&gt; overlap_matrix(sa, sb)
4×4 SparseArrays.SparseMatrixCSC{EnergyExpressions.NBodyTerm,Int64} with 2 stored entries:
  [1, 1]  =  1
  [2, 2]  =  1</code></pre><p>which has only two non-zero entries, since only two of the orbitals are common between the Slater determinants <code>sa</code> and <code>sb</code>.</p><p>We can then define that the orbitals <code>k̃</code> and <code>l̃</code> are non-orthogonal:</p><pre><code class="language-julia-repl hljs">julia&gt; overlap_matrix(sa, sb, [OrbitalOverlap(:k̃,:l̃)])
4×4 SparseArrays.SparseMatrixCSC{EnergyExpressions.NBodyTerm,Int64} with 3 stored entries:
  [1, 1]  =  1
  [2, 2]  =  1
  [4, 4]  =  ⟨k̃|l̃⟩</code></pre><p>We can even specify that the orbital <code>k̃</code> is non-orthogonal to <em>itself</em> (this can be useful when the <code>k̃</code> is a linear combination of orthogonal orbitals):</p><pre><code class="language-julia-repl hljs">julia&gt; overlap_matrix(sa, sa, [OrbitalOverlap(:k̃,:k̃)])
4×4 SparseArrays.SparseMatrixCSC{EnergyExpressions.NBodyTerm,Int64} with 4 stored entries:
  [1, 1]  =  1
  [2, 2]  =  1
  [3, 3]  =  1
  [4, 4]  =  ⟨k̃|k̃⟩</code></pre><p>Notice that this overlap matrix was calculated between the Slater determinant <code>sa</code> and itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L634-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.EnergyExpression" href="#EnergyExpressions.EnergyExpression"><code>EnergyExpressions.EnergyExpression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EnergyExpression</code></pre><p>An energy expression is given by an energy matrix, or interaction matrix, sandwiched between a vector of mixing coefficients: <code>E = c&#39;H*c</code>, where <code>c</code> are the mixing coefficients and <code>H</code> the energy matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L706-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Matrix" href="#Base.Matrix"><code>Base.Matrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matrix(a, op::QuantumOperator, b[, overlaps])</code></pre><p>Generate the matrix corresponding to the quantum operator <code>op</code>, between the <a href="../slater_determinants/#EnergyExpressions.SlaterDeterminant"><code>SlaterDeterminant</code></a>s <code>a</code> and <code>b</code>, i.e <code>⟨a|op|b⟩</code>. It is possible to specify non-orthogonalities between single-particle orbitals in <code>overlaps</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L716-L723">source</a></section><section><div><pre><code class="nohighlight hljs">Matrix(op::QuantumOperator, slater_determinants[, overlaps])</code></pre><p>Generate the matrix corresponding to the quantum operator <code>op</code>, between the different <code>slater_determinants</code>. It is possible to specify non-orthogonalities between single-particle orbitals in <code>overlaps</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L764-L770">source</a></section></article><h2 id="Calculation-of-determinants"><a class="docs-heading-anchor" href="#Calculation-of-determinants">Calculation of determinants</a><a id="Calculation-of-determinants-1"></a><a class="docs-heading-anchor-permalink" href="#Calculation-of-determinants" title="Permalink"></a></h2><p>Actually computing the matrix element expansion <span>$\eqref{eqn:matrix-element-expansion}$</span> is a combinatorial problem, that grows factorially with the amount of non-orthogonal orbital pairs. Furthermore, of the <span>$(n!)^2$</span> terms generated from the expansion, only <span>$n!$</span> are distinct, due to the integrals being symmetric with respect to interchange of the coordinates [hence the normalization factor <span>$(n!)^{-1}$</span>]. Thankfully, there are few symmetries that can be employed, to generate only the distinct permutations, as well as the fact that the overlap matrix is very sparse.</p><h3 id="Finding-non-zero-minors-of-the-overlap-determinant"><a class="docs-heading-anchor" href="#Finding-non-zero-minors-of-the-overlap-determinant">Finding non-zero minors of the overlap determinant</a><a id="Finding-non-zero-minors-of-the-overlap-determinant-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-non-zero-minors-of-the-overlap-determinant" title="Permalink"></a></h3><p>The algorithm to find which minor determinants <span>$\Gamma^{(N)}(k_1k_2...k_N|l_1l_2...l_N)$</span> do not vanish, and hence which <span>$N$</span> orbitals <span>$k_1k_2...k_N,l_1l_2...l_N$</span> the <span>$N$</span>-body operator should be contracted over, is described briefly below. It is devised to be optimal for orthogonal orbitals (i.e. linear complexity <span>$\mathcal{O}(Nn)$</span> where <span>$n$</span> is the number of orbitals), and near-optimal for a small amount of non-orthogonal orbitals.</p><p>Given:</p><ul><li>An <span>$N$</span>-body operator (implying <span>$N$</span> rows and <span>$N$</span> need to stricken out), and</li><li>an <span>$n\times n$</span> matrix, with coordinates of non-zero matrix elements: <span>$I,J$</span> (from these vectors, vanishing rows/columns can easily be deduced <span>$\implies$</span> <span>$N_r$</span> row/<span>$N_c$</span> column &quot;rank&quot;, i.e. yet to be stricken out),</li></ul><p>do</p><ul><li>find all <span>$N_r$</span>-combinations of the remaining rows,</li><li>for each such combination, find all columns which would be affected if striking out that particular combination of rows,<ul><li>if the &quot;support&quot; (i.e. the only non-zero elements) of any of those columns vanishes when striking out the rows, that column must be stricken out, too. Total number of these columns is named <span>$N_{cm}$</span>,</li><li>if more than <span>$N_c$</span> columns must be stricken out (<span>$N_{cm}&gt;N_c$</span>), that row combination is unviable,</li><li>find all <span>$N_c - N_{cm}$</span>-combinations of the remaining columns,</li><li>for each such combination of columns, find all rows which would be affected,<ul><li>if the support of any of those rows vanishes when striking out the candidate columns, and the row is not in the candidate set of rows to be stricken out, the column combination is unviable.</li></ul></li></ul></li></ul><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.nonzero_minors" href="#EnergyExpressions.nonzero_minors"><code>EnergyExpressions.nonzero_minors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonzero_minors(N, overlap) -&gt; (ks,ls)</code></pre><p>Find all (distinct) minor determinants of order <code>N</code> of the orbital <code>overlap</code> matrix that do not vanish, i.e. all non-vanishing minors are guaranteed to be present, but not all of the returned minors are guaranteed to be non-zero. Vanishing minors returned arise when the overlap matrix is rank deficient, which is unlikely to happen when computing energy expressions, but must still be guarded against. This is most easily checked by actually calculating the <a href="#EnergyExpressions.cofactor"><code>cofactor</code></a>, which is most likely desired anyway.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/minors.jl#L3-L14">source</a></section></article><h3 id="Contracting-over-the-stricken-out-orbitals"><a class="docs-heading-anchor" href="#Contracting-over-the-stricken-out-orbitals">Contracting over the stricken out orbitals</a><a id="Contracting-over-the-stricken-out-orbitals-1"></a><a class="docs-heading-anchor-permalink" href="#Contracting-over-the-stricken-out-orbitals" title="Permalink"></a></h3><p>We use Julia&#39;s built-in <code>Base.Cartesian.@nloops</code> iterators to span the space of all possible choices of orbitals for the contraction of orbitals. If two or more orbitals are the same, the matrix element is trivially zero (the “Fermi hole”). To avoid double-counting, we also only consider those indices that are above the hyper-diagonal.</p><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.detaxis" href="#EnergyExpressions.detaxis"><code>EnergyExpressions.detaxis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">detaxis(i::CartesianIndex{N})</code></pre><p>Generate the axis index vector for the determinant minor, whose rows or columns represented by the <code>CartesianIndex</code> <code>i</code> should be omitted. Implemented via <a href="../nbody_operators/#EnergyExpressions.complement"><code>complement</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L382-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.detminor" href="#EnergyExpressions.detminor"><code>EnergyExpressions.detminor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">detminor(k, l, A)</code></pre><p>Calculate the <a href="https://en.wikipedia.org/wiki/Minor_(linear_algebra)">determinant minor</a> of <code>A</code>, where the rows <code>k</code> and the columns <code>l</code> have been stricken out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L394-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.cofactor" href="#EnergyExpressions.cofactor"><code>EnergyExpressions.cofactor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cofactor(k, l, A)</code></pre><p>Calculate the <a href="https://en.wikipedia.org/wiki/Minor_(linear_algebra)">cofactor</a> of <code>A</code>, where the rows <code>k</code> and the columns <code>l</code> have been stricken out. The cofactor is calculated recursively, by expanding the minor determinants in cofactors, so this function should only be used in case it is known that the cofactor is non-zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L419-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.det" href="#LinearAlgebra.det"><code>LinearAlgebra.det</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">det(A)</code></pre><p>Calculate the determinant of the matrix <code>A</code> whose elements are of the <a href="#EnergyExpressions.NBodyTerm"><code>NBodyTerm</code></a> type, by expanding the determinant along the first column. This is an expensive operation, and should only be done with relatively sparse matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L475-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.permutation_sign" href="#EnergyExpressions.permutation_sign"><code>EnergyExpressions.permutation_sign</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permutation_sign(p)</code></pre><p>Calculate the sign of the permutation <code>p</code>, 1 if <code>iseven(p)</code>, -1 otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L510-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.powneg1" href="#EnergyExpressions.powneg1"><code>EnergyExpressions.powneg1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">powneg1(k) = (-)ᵏ</code></pre><p>Calculates powers of negative unity for integer <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/nbody_matrix_elements.jl#L412-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.@above_diagonal_loop" href="#EnergyExpressions.@above_diagonal_loop"><code>EnergyExpressions.@above_diagonal_loop</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">above_diagonal_loop(N, itersym, imax, args...)</code></pre><p>Generate <code>N</code> Cartesian loops for the iteration variables <code>itersym_{1:N}</code>, where <code>itersym_N ∈ 1:imax</code>, <code>itersym_{N-1} ∈ itersym_N+1:imax</code>, etc, i.e. above the hyper-diagonal of the <code>N</code>-dimensional hypercube with the side <code>imax</code>. <code>args...</code> is passed on to <code>Base.Cartesian._nloops</code>. <code>above_diagonal_loop</code> is nestable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @above_diagonal_loop 2 i 3 begin
           println(&quot;==================================&quot;)
           println(&quot;i = &quot;, Base.Cartesian.@ntuple 2 i)
           @above_diagonal_loop 2 j 3 begin
               println(&quot;j = &quot;, Base.Cartesian.@ntuple 2 j)
           end
       end
==================================
i = (2, 1)
j = (2, 1)
j = (3, 1)
j = (3, 2)
==================================
i = (3, 1)
j = (2, 1)
j = (3, 1)
j = (3, 2)
==================================
i = (3, 2)
j = (2, 1)
j = (3, 1)
j = (3, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/loop_macros.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnergyExpressions.@anti_diagonal_loop" href="#EnergyExpressions.@anti_diagonal_loop"><code>EnergyExpressions.@anti_diagonal_loop</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">anti_diagonal_loop(N, itersym, imax, args...)</code></pre><p>Generate <code>N</code> Cartesian loops for the iteration variables <code>itersym_{1:N}</code>, where <code>itersym_N ∈ 1:imax</code>, <code>itersym_{N-1} ∈ 1:imax\itersym_N</code>, etc, i.e. no two iteration variables have the same values simultaneously. <code>args...</code> is passed on to <code>Base.Cartesian._nloops</code>; however, <code>preexpr</code> is already used to skip the diagonal elements. <code>anti_diagonal_loop</code> is nestable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @anti_diagonal_loop 3 i 3 begin
           println(&quot;-----------------------------&quot;)
           t = (Base.Cartesian.@ntuple 3 i)
           println(&quot;$t: &quot;, allunique(t))
           @anti_diagonal_loop 2 j 2 begin
               u = (Base.Cartesian.@ntuple 2 j)
               println(&quot;$u: &quot;, allunique(u))
           end
       end
-----------------------------
(3, 2, 1): true
(2, 1): true
(1, 2): true
-----------------------------
(2, 3, 1): true
(2, 1): true
(1, 2): true
-----------------------------
(3, 1, 2): true
(2, 1): true
(1, 2): true
-----------------------------
(1, 3, 2): true
(2, 1): true
(1, 2): true
-----------------------------
(2, 1, 3): true
(2, 1): true
(1, 2): true
-----------------------------
(1, 2, 3): true
(2, 1): true
(1, 2): true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/EnergyExpressions.jl/blob/4cbbbbb4c6f0946268743f44ef4744a007aabc64/src/loop_macros.jl#L43-L90">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nbody_operators/">« N-body operators</a><a class="docs-footer-nextpage" href="../common_operators/">Common N-body operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Friday 22 July 2022 07:26">Friday 22 July 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
